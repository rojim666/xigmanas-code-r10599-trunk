<?php
/*
	util.inc

	Part of XigmaNAS® (https://www.xigmanas.com).
	Copyright © 2018-2025 XigmaNAS® <info@xigmanas.com>.
	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions are met:

	1. Redistributions of source code must retain the above copyright notice, this
	   list of conditions and the following disclaimer.

	2. Redistributions in binary form must reproduce the above copyright notice,
	   this list of conditions and the following disclaimer in the documentation
	   and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
	DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
	ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

	The views and conclusions contained in the software and documentation are those
	of the authors and should not be interpreted as representing official policies
	of XigmaNAS®, either expressed or implied.
*/

require_once 'autoload.php';
require_once 'super_fun.inc';
require_once 'globals.inc';
require_once 'system.inc';

use common\arr;
use common\uuid;

//	set PATH, otherwise some commands will not be found during exec.
putenv('PATH=/bin:/sbin:/usr/bin:/usr/sbin:/usr/local/bin:/usr/local/sbin');

function is_numericint($arg) {
	return(preg_match('/[^0-9]/',$arg) ? false : true);
}
/**
 *	Check if parameter is a valid IPv4 or IPv6 address
 *	@param mixed $ipaddr
 *	@return boolean
 */
function is_ipaddr($ipaddr) {
	if(filter_var($ipaddr,FILTER_VALIDATE_IP,FILTER_FLAG_IPV4)):
		return true;
	endif;
	if(filter_var($ipaddr,FILTER_VALIDATE_IP,FILTER_FLAG_IPV6)):
		return true;
	endif;
	return false;
}
/**
 *	Check if parameter is a valid IPv4 address
 *	@param mixed $ipv4addr
 *	@return boolean
 */
function is_ipv4addr($ipv4addr): bool {
	return(filter_var($ipv4addr,FILTER_VALIDATE_IP,FILTER_FLAG_IPV4) !== false);
}
/**
 *	Check if parameter is a valid IPv6 address
 *	@param mixed $ipv6addr
 *	@return boolean
 */
function is_ipv6addr($ipv6addr): bool {
	return(filter_var($ipv6addr,FILTER_VALIDATE_IP,FILTER_FLAG_IPV6) !== false);
}
/**
 *	Check if parameter is a valid subnet in CIDR format
 *	@param mixed $subnet
 *	@return boolean
 */
function is_subnet($subnet): bool {
	if(is_string($subnet)):
		$a = explode('/',$subnet);
		if(count($a) === 2):
//			if it's an IPv4 address, but with a bitcount outside 1-32 range, there is a problem
			if(is_ipv4addr($a[0]) && is_numeric($a[1]) && ($a[1] > 0) && ($a[1] <= 32)):
				return true;
			endif;
//			if it's an IPv6 address, but with a bitcount outside 1-64 range, there is a problem
			if(is_ipv6addr($a[0]) && is_numeric($a[1]) && ($a[1] > 0) && ($a[1] <= 128)):
				return true;
			endif;
		endif;
	endif;
	return false;
}
/*
 *	returns true if $hostname is a valid hostname
 */
function is_hostname($hostname) {
	if(is_string($hostname)):
		if(preg_match("/^[a-z0-9\-]+$/i",$hostname)):
			return true;
		endif;
	endif;
	return false;
}
/*
 *	returns true if $desc is a valid description (alphanum and space,_ ,- ,.)
 */
function is_validdesc($desc) {
	if(is_string($desc)):
		if(preg_match("/^[A-Za-z0-9]([A-Za-z0-9_\-\.\s]*[A-Za-z0-9])*$/",$desc)):
			return true;
		endif;
	endif;
	return false;
}
/*
 *	returns true if $login is a valid login name (alphanum,dot,_ ,-)
 */
function is_validlogin($login) {
	if(!is_string($login)):
		return false;
	endif;
	if(preg_match("/[^a-zA-Z0-9\.\-_]/",$login)):
		return false;
	endif;
	return true;
}
/*
 *	returns true if $password is a valid password (not used of special : character)
 */
function is_validpassword($password) {
	if(is_string($password)):
		if(!strstr($password,':')):
			return true;
		endif;
	endif;
	return false;
}
/*
 *	returns true if $sharename is a valid share name (alphanum,dot,_ ,-)
 */
function is_validsharename($sharename) {
	if(is_string($sharename)):
		if(preg_match("/^[a-z\d]([a-z\d_\-\.\s]*[a-z\d])*$/i",$sharename)):
			return true;
		endif;
	endif;
	return false;
}
/*
 *	Returns true if $domain is a valid domain name
 */
function is_domain($domain) {
	if(is_string($domain)):
		if(preg_match("/^([a-z0-9_\-]+\.?)*$/i",$domain)):
			return true;
		endif;
	endif;
	return false;
}
/*
 *	Returns true if $string is a valid NetBIOS name
 *	See reference http://support.microsoft.com/kb/909264
 *	Update reference http://support.microsoft.com/kb/188997/en-us
 *	The following characters are not allowed: \ / : * ? " < > |
 */
function is_netbios($string) {
	if(15 < strlen($string)):
		return false;
	endif;
	if(preg_match("/^[^\.]([^\\/:*\?\"<>|])*$/i",$string)):
		return true;
	endif;
	return false;
}
/*
 *	Returns true if $workgroup is a valid workgroup name
 *	A workgroup name can contain up to 15 characters, including letters, numbers,
 *	and the following characters: ! @ # $ % ^ & ( ) _ - ; : ' " , .
 *	It cannot contain any spaces, and must begin with a letter or number.
 */
function is_workgroup($workgroup) {
	if(!is_string($workgroup)):
		return false;
	endif;
	if(preg_match("/^[\w\d]+[\w\d\!\@\#\$\%\^\&\(\)\_\-\;\:\'\"\,\.]*$/",$workgroup)):
		return true;
	endif;
	return false;
}
/*
 *	returns true if $macaddr is a valid MAC address
 */
function is_macaddr($macaddr) {
	if(!is_string($macaddr)):
		return false;
	endif;
	$maca = explode(':',$macaddr);
	if(count($maca) != 6):
		return false;
	endif;
	foreach($maca as $macel):
		if(($macel === '') || (strlen($macel) > 2)):
			return false;
		endif;
		if(preg_match("/[^0-9a-f]/i",$macel)):
			return false;
		endif;
	endforeach;
	return true;
}
/*
 *	returns true if $name is a valid name for an alias
 */
function is_validaliasname($name) {
	if(!is_string($name)):
		return false;
	endif;
	if(!preg_match("/^[a-zA-Z0-9]*$/",$name)):
		return false;
	endif;
	return true;
}
/*
 *	returns true if $port is a valid TCP/UDP port
 */
function is_port($port) {
	if(!is_numericint($port)):
		return false;
	endif;
	if(($port < 1) || ($port > 65535)):
		return false;
	endif;
	return true;
}
/*
 *	returns true if $mtu is a valid MTU size
 */
function is_mtu($mtu) {
	if(!is_numericint($mtu)):
		return false;
	endif;
	if(($mtu < 100) || ($mtu > 9000)):
		return false;
	endif;
	return true;
}
/*
 * Validate the given file mode mask. Valid masks are in the
 * range from [0]000 to [0]777.
 * @param mode The file mode mask as octal value to validate
 * @return Returns true if mode is a valid file mode mask.
 */
function is_filemode($mode) {
	if(!is_numericint($mode)):
		return false;
	endif;
	if(!preg_match("/^[0]?[0-7]{3}$/",$mode)):
		return false;
	endif;
	return true;
}
/*
 *	Returns true if $certificate is a valid certificate.
 */
function is_valid_certificate($certificate) {
	if(preg_match('/^(-----BEGIN CERTIFICATE-----).*(-----END CERTIFICATE-----)(\r|\n|\r\n)?\z/s',$certificate)):
		return true;
	endif;
	return false;
}
/*
 *	Returns true if $privatekey is a valid format.
 *	@param mixed $privatekey The private key
 *	@param string $type Check for specific private key label, i.e. RSA or for any private key (null)
 *	@return boolean
 */
function is_valid_privatekey($privatekey,?string $type = null) {
//	RFC 7468, https://www.rfc-editor.org/rfc/rfc7468
	$result = false;
	if(is_string($privatekey)):
		$regexp = '/^(?:-----BEGIN )(|(?<type>[\x21-\x2c,\x2e-\x7e]+(?:[- ][\x21-\x2c,\x2e-\x7e]+)*) )(?:PRIVATE KEY-----)(?:.*)(?:-----END )(?:\1)(?:PRIVATE KEY-----)(?:\r|\n|\r\n)?\z/s';
		$matches = null;
		if(preg_match($regexp,$privatekey,$matches) === 1):
			switch($type):
				case null:
//					file format matches RFC
					$result = true;
					break;
				default:
//					check if file is for given type
					$result = ($type === $matches['type'] ?? false);
					break;
			endswitch;
		endif;
	endif;
	return $result;
}
/**
 *	Returns true if $uuid is a valid UUID.
 *	@param string $uuid Universal Unique Identifier
 *	@return bool returns true if the given string is a valid uuid.
 */
function is_uuid_v4($uuid): bool {
	return uuid::is_v4($uuid);
}
/**
 *	Determines the use of binary prefixes instead of decimal prefixes.
 *	@global array $config
 *	@return bool Returns true when SI (base 1000) should be used, false if not.
 */
function is_sidisksizevalues(): bool {
	global $config;

	$retbool = !(is_bool($test = $config['system']['webgui']['nonsidisksizevalues'] ?? false) ? $test : true);
	return $retbool;
}
/*
 *
 */
function get_interface_list() {
	global $g;

//	build interface list with netstat
	exec("/usr/bin/netstat -inW -f link",$linkinfo);
	array_shift($linkinfo);
	$iflist = [];
	foreach($linkinfo as $link):
		$alink = preg_split("/\s+/",ltrim($link));
		$ifname = chop($alink[0]);
		if(substr($ifname,-1) === '*'):
			$ifname = substr($ifname,0,strlen($ifname) - 1);
		endif;
//		skip wireless
		if(preg_match($g['wireless_regex'],$ifname)):
			continue;
		endif;
//		add the plip interface to be excluded too
		if(!preg_match("/^(ppp|sl|gif|faith|lo|vlan|tun|plip|ipfw|usbus|carp)/",$ifname)):
			$iflist[$ifname] = [];
			$iflist[$ifname]['mac'] = chop($alink[3]);
			$iflist[$ifname]['up'] = false;
//			find out if the link on this interface is up
			unset($ifinfo);
			exec("/sbin/ifconfig {$ifname}",$ifinfo);
			foreach($ifinfo as $ifil):
				if(preg_match("/status: (.*)$/",$ifil,$matches)):
					if($matches[1] === 'active'):
						$iflist[$ifname]['up'] = true;
					endif;
					break;
				endif;
			endforeach;
		endif;
	endforeach;
	return $iflist;
}
/*
 *
 */
function get_interface_wlist() {
	global $g;

	$iflist = [];
	$osver = @exec("/usr/bin/uname -U");
	if($osver >= 1100000):
		$devs = @exec("/sbin/sysctl -n net.wlan.devices");
		$ifs = explode(' ',$devs);
		foreach($ifs as $ifname):
			$iflist[$ifname] = [];
			$iflist[$ifname]['mac'] = '00:00:00:00:00:00';
			$iflist[$ifname]['up'] = false;
		endforeach;
		return $iflist;
	endif;
//	build interface list with netstat
	exec("/usr/bin/netstat -inW -f link",$linkinfo);
	array_shift($linkinfo);
	foreach($linkinfo as $link):
		$alink = preg_split("/\s+/",ltrim($link));
		$ifname = chop($alink[0]);
		if(substr($ifname,-1) === '*'):
			$ifname = substr($ifname,0,strlen($ifname) - 1);
		endif;
//		skip lo, wlan
		if(preg_match("/^(lo|wlan)/",$ifname)):
			continue;
		endif;
		if(preg_match($g['wireless_regex'],$ifname)):
			$iflist[$ifname] = [];
			$iflist[$ifname]['mac'] = chop($alink[3]);
			$iflist[$ifname]['up'] = false;
//			find out if the link on this interface is up
			unset($ifinfo);
			exec("/sbin/ifconfig {$ifname}",$ifinfo);
			foreach($ifinfo as $ifil):
				if(preg_match("/status: (.*)$/",$ifil,$matches)):
					if($matches[1] === 'active'):
						$iflist[$ifname]['up'] = true;
					endif;
					break;
				endif;
			endforeach;
		endif;
	endforeach;
	return $iflist;
}
/*
 *
 */
function get_wlan_interface_list() {
	global $g;

//	build interface list with netstat
	exec("/usr/bin/netstat -inW -f link",$linkinfo);
	array_shift($linkinfo);
	$iflist = [];
	foreach($linkinfo as $link):
		$alink = preg_split("/\s+/",ltrim($link));
		$ifname = chop($alink[0]);
		if(substr($ifname,-1) === '*'):
			$ifname = substr($ifname,0,strlen($ifname) - 1);
		endif;
		if(preg_match("/^(wlan)/",$ifname)):
			$iflist[$ifname] = [];
			$iflist[$ifname]['mac'] = chop($alink[3]);
			$iflist[$ifname]['up'] = false;
//			find out if the link on this interface is up
			unset($ifinfo);
			exec("/sbin/ifconfig {$ifname}",$ifinfo);
			foreach($ifinfo as $ifil):
				if(preg_match("/status: (.*)$/",$ifil,$matches)):
					if($matches[1] === 'active'):
						$iflist[$ifname]['up'] = true;
					endif;
					break;
				endif;
			endforeach;
		endif;
	endforeach;
	return $iflist;
}
/*
 *	Get list of mounted disk
 *	example: Array
 *	[0] => Array [
 *		[mp] => /mnt/sharename
 *		[mdisk] => ad0s1
 *		[devicespecialfile] => /dev/ad0s1
 *		[sharename] => sharename
 *		[fsid] => 090db747f2d532ed
 *	]
 */
function get_mounts_list() {
	global $g;

	$amountlist = [];
	$i = 0;
//	get list of mount points.
	exec("/sbin/mount -v",$rawdata);
	foreach($rawdata as $line):
//		e.g.: /dev/ad8p1 on /mnt/xyz (ufs, local, soft-updates, acls, fsid 66ad394809fce81b)
		if(0 == preg_match("/^(\S+) on (.+) \(.+fsid (\S+).+$/",$line,$aline)):
			continue;
		endif;
//		get device path
		$devicespecialfile = chop($aline[1]);
//		get the mount path
		$mountpath = chop($aline[2]);
//		ignore various mountpoints
		if(('/' === $mountpath) || ('devfs' === $devicespecialfile) || ('procfs' === $devicespecialfile) || ('tmpfs' === $devicespecialfile) ||
			('/var' === $mountpath) || ('/dev/fd0' === $devicespecialfile) || ($g['cf_path'] === $mountpath)):
			continue;
		endif;
//		get the complete name /dev/devicename
		$adevicespecialfile = explode('/',$devicespecialfile);
		if(empty($adevicespecialfile[2])):
			$devicename = $adevicespecialfile[1] ?? '';
			#continue;
		else:
			$devicename = $adevicespecialfile[2] ?? '';
		endif;
//		test if it's a gvinum, gmirror, gconcat or gstripe device
		if((strcmp($devicename,'gvinum') == 0) || (strcmp($devicename,'mirror') == 0) || (strcmp($devicename,'concat') == 0) || (strcmp($devicename,'stripe') == 0)):
			$devicename = $adevicespecialfile[3];
		endif;
//		get the sharename
		$amountpath = explode('/',$mountpath);
		$amountlist[$i]['mp'] = $mountpath;
		$amountlist[$i]['mdisk'] = $devicename;
		$amountlist[$i]['devicespecialfile'] = $devicespecialfile;
		$amountlist[$i]['sharename'] = end($amountpath);
		$amountlist[$i]['fsid'] = chop($aline[3]);
		$i++;
	endforeach;
	return $amountlist;
}
/**
 *	Retrieve the fsid from mount point.
 *	@param string $devicespecialfile The device special name, e.g. /dev/ad6p1
 *	@param string $mountpoint The name of the mount point, e.g. /mnt/1
 *	@return string fsid or empty
 */
function get_mount_fsid($devicespecialfile,$mountpoint) {
	unset($rawdata);
	exec('/sbin/mount -v',$rawdata);
	if(!empty($rawdata)):
		$needle = sprintf('%s on %s ',$devicespecialfile,$mountpoint);
		foreach($rawdata as $mountinfo):
//			parse string: /dev/ad6p1 on /mnt/1 (ufs, local, soft-updates, acls, fsid 090db747f2d532ed)
			if(1 === preg_match('/' . preg_quote($needle,'/') . '.+fsid (\S+).+/',$mountinfo,$info)):
				return $info[1];
			endif;
		endforeach;
	endif;
	return '';
}
/*
 *	Return list of ALL software volume: gvinum, gmirror
 */
function get_sraid_disks_list() {
	$disklist = array_merge((array)get_gvinum_disks_list(),(array)get_gmirror_disks_list(),(array)get_gconcat_disks_list(),(array)get_gstripe_disks_list());
	return $disklist;
}
/*
 *	Get list of software gvinum RAID disks.
 *	[volumename] => [
 *		[type] => gvinum
 *		[state] => UP
 *		[size] => 6149 MB
 *		[name] => VolumeName
 *		[devicespecialfile] => /dev/gvinum/VolumeName
 *		[desc] => Software RAID
 *	]
 */
function get_gvinum_disks_list() {
	$disklist = [];
//	send the shell cmd and get the result
	exec("/sbin/gvinum list",$rawdata);
	$use_si = is_sidisksizevalues();
	foreach($rawdata as $line):
//		split the line using the space as separator
		$aline = preg_split("/\s+/",$line);
//		get the line that begin with the letter 'V'
		if($aline[0] != 'V'):
			continue;
		endif;
		$diskname = chop($aline[1]);
		$disklist[$diskname] = [];
		$disklist[$diskname]['name'] = $diskname;
		$disklist[$diskname]['devicespecialfile'] = '/dev/gvinum/' . $diskname;
		$disklist[$diskname]['type'] = 'gvinum';
		$disklist[$diskname]['desc'] = 'Software RAID';
		$disklist[$diskname]['state'] = $aline[3];
//		get diskinfo to get disk size
		$diskinfo = disks_get_diskinfo($disklist[$diskname]['devicespecialfile']);
		$disklist[$diskname]['size'] = isset($diskinfo['mediasize_bytes']) ? format_bytes($diskinfo['mediasize_bytes'],2,true,$use_si) : gtext('Unknown');
	endforeach;
	return $disklist;
}
/*
 *	Get list of software gmirror RAID disks.
 *	[volumename] => [
 *		[type] => gmirror
 *		[name] => volumename
 *		[state] => COMPLETE
 *		[size] => 6149M
 *		[devicespecialfile] => /dev/mirror/volumename
 *		[desc] => Software RAID
 *	]
 */
function get_gmirror_disks_list() {
	$disklist = [];
//	display all configured gmirror volume
	exec("/sbin/gmirror list",$rawdata);
	$foundstate = $foundname = 0 ;
	$use_si = is_sidisksizevalues();
	foreach($rawdata as $line):
//		use space for break the line
		$aline = preg_split("/\s+/",$line);
//		first step: Getting the array name
//		look for this output:
//		Geom name: xxx
		if((strcmp($aline[0],'Geom') == 0) && (strcmp($aline[1],'name:') == 0)):
			$diskname = $aline[2];
			$disklist[$diskname] = [];
			$disklist[$diskname]['name'] = $diskname;
			$disklist[$diskname]['devicespecialfile'] = '/dev/mirror/' . $diskname;
			$disklist[$diskname]['type'] = 'gmirror';
			$disklist[$diskname]['desc'] = 'Software RAID';
			$disklist[$diskname]['state'] = gtext('Unknown');
//			get diskinfo to get disk size
			$diskinfo = disks_get_diskinfo($disklist[$diskname]['devicespecialfile']);
			$disklist[$diskname]['size'] = isset($diskinfo['mediasize_bytes']) ? format_bytes($diskinfo['mediasize_bytes'],2,true,$use_si) : gtext('Unknown');
			$foundname = 1 ;
			continue ;
		endif;
//		second step: Getting the array status
//		look for this output:
//		State: COMPLETE
		if((strcmp($aline[0],'State:') == 0) && $foundname):
			$disklist[$diskname]['state'] = $aline[1];
//			check next
			$foundname = 0 ;
			$foundstate = 1 ;
			continue ;
		endif;
//		look for this output:
//		Balance: round-robin
		if((strcmp($aline[0],'Balance:') == 0) && $foundstate):
			$disklist[$diskname]['balance'] = $aline[1];
//			init the check variable for the next RAID volume
			$foundstate = 0 ;
			continue ;
		endif;
	endforeach;
	return $disklist;
}
/*
 *	Get list of software gconcat RAID disks.
 *	[volumename] => [
 *		[type] => gconcat
 *		[state] => COMPLETE
 *		[size] => 6149M
 *		[name] => concat1
 *		[devicespecialfile] => /dev/concat/concat1
 *		[desc] => Software RAID
 *	]
 */
function get_gconcat_disks_list() {
	$disklist = [];
//	display all configured gconcat volume
	exec("/sbin/gconcat list",$rawdata);
	$foundname = 0;
	$use_si = is_sidisksizevalues();
	foreach($rawdata as $line):
//		use space for break the line
		$aline = preg_split("/\s+/",$line);
//		first Step: Getting the array name
//		look for this output:
//		GEOM name: xxx
		if((strcmp($aline[0],'Geom') == 0) && (strcmp($aline[1],'name:') == 0)):
			$diskname = $aline[2];
			$disklist[$diskname] = [];
			$disklist[$diskname]['name'] = $diskname;
			$disklist[$diskname]['devicespecialfile'] = '/dev/concat/' . $diskname;
			$disklist[$diskname]['type'] = 'gconcat';
			$disklist[$diskname]['desc'] = 'Software RAID';
			$disklist[$diskname]['state'] = gtext('Unknown');
//			get diskinfo to get disk size
			$diskinfo = disks_get_diskinfo($disklist[$diskname]['devicespecialfile']);
			$disklist[$diskname]['size'] = isset($diskinfo['mediasize_bytes']) ? format_bytes($diskinfo['mediasize_bytes'],2,true,$use_si) : gtext('Unknown');
			$foundname = 1 ;
			continue ;
		endif;
//		second step: Getting the array status
//		look for this output:
//		state: UP
		if((strcmp($aline[0],'State:') == 0) && $foundname):
			$disklist[$diskname]['state'] = $aline[1];
//			init the check variable for the next RAID volume
			$foundname = 0 ;
			continue ;
		endif;
	endforeach;
	return $disklist;
}
/*
 *	Get list of software gstripe RAID disks.
 *	[volumename] => [
 *		[type] => gstripe
 *		[state] => COMPLETE
 *		[size] => 6149M
 *		[name] => raid0
 *		[devicespecialfile] => /dev/stripe/raid0
 *		[desc] => Software RAID
 *	]
 */
function get_gstripe_disks_list() {
	$disklist = [];
//	display all configured gstripe volume
	exec("/sbin/gstripe list",$rawdata);
	$foundname = 0;
	$use_si = is_sidisksizevalues();
	foreach($rawdata as $line):
//		use space for break the line
		$aline = preg_split("/\s+/",$line);
//		first step: Getting the array name
//		look for this output:
//		Geom name: xxx
		if((strcmp($aline[0],'Geom') == 0) && (strcmp($aline[1],'name:') == 0)):
			$diskname = $aline[2];
			$disklist[$diskname] = [];
			$disklist[$diskname]['name'] = $diskname;
			$disklist[$diskname]['devicespecialfile'] = '/dev/stripe/' . $diskname;
			$disklist[$diskname]['type'] = 'gstripe';
			$disklist[$diskname]['desc'] = 'Software RAID';
			$disklist[$diskname]['state'] = gtext('Unknown');
//			get diskinfo to get disk size
			$diskinfo = disks_get_diskinfo($disklist[$diskname]['devicespecialfile']);
			$disklist[$diskname]['size'] = isset($diskinfo['mediasize_bytes']) ? format_bytes($diskinfo['mediasize_bytes'],2,true,$use_si) : gtext('Unknown');
			$foundname = 1 ;
			continue ;
		endif;
//		second step: Getting the array status
//		look for this output:
//		state: UP
		if((strcmp($aline[0],'State:') == 0) && $foundname):
			$disklist[$diskname]['state'] = $aline[1];
//			init the check variable for the next RAID volume
			$foundname = 0 ;
			continue ;
		endif;
	endforeach;
	return $disklist;
}
/*
 *	Get list of HAST disks.
 *	[volumename] => [
 *		[type] => HAST
 *		[name] => volumename
 *		[role] => primary
 *		[status] => complete
 *		[size] => 6149MB
 *		[devicespecialfile] => /dev/hast/volumename
 *		[localpath] => /dev/da1
 *		[desc] => HAST device
 *	]
 */
function get_hast_disks_list() {
	$disklist = [];
	$use_si = is_sidisksizevalues();
	exec('/sbin/hastctl list 2>/dev/null',$rawdata);
	foreach($rawdata as $line):
		if(preg_match('/^(\S+):$/',$line,$match)):
			$diskname = trim($match[1]);
			$disklist[$diskname] = [];
			$disklist[$diskname]['name'] = $diskname;
			$disklist[$diskname]['devicespecialfile'] = '/dev/hast/' . $diskname;
			$disklist[$diskname]['type'] = 'HAST';
			$disklist[$diskname]['model'] = 'HAST device';
			$disklist[$diskname]['desc'] = 'HAST device';
			$disklist[$diskname]['role'] = gtext('Unknown');
			$disklist[$diskname]['status'] = gtext('Unknown');
			$disklist[$diskname]['localpath'] = '';
		elseif(preg_match('/^\s+role:\s+(.+)$/',$line,$match)):
			$role = trim($match[1]);
			$disklist[$diskname]['role'] = $role;
			if($role == 'primary'):
				$diskinfo = disks_get_diskinfo($disklist[$diskname]['devicespecialfile']);
				$disklist[$diskname]['size'] = isset($diskinfo['mediasize_bytes']) ? format_bytes($diskinfo['mediasize_bytes'],2,true,$use_si) : gtext('Unknown');
			else:
				$disklist[$diskname]['size'] = 'N/A';
			endif;
		elseif(preg_match('/^\s+localpath:\s+(.+)$/',$line,$match)):
			$localpath = trim($match[1]);
			$disklist[$diskname]['localpath'] = $localpath;
		elseif(preg_match('/^\s+status:\s+(.+)$/',$line,$match)):
			$state = trim($match[1]);
			$disklist[$diskname]['status'] = $state;
		endif;
	endforeach;
	return $disklist;
}
/**
 *	smartd and smartcl require a parameter if an alternative drive database is to be used.
 *	The parameter is created
 *	- when a filename is configured in config.xml ['smartd']['drivedb'] and exists.
 *	- when a filename is configured in rc.conf 'smartd_drivedb' and exists.
 *	The config.xml setting precedes the rc.conf setting.
 *	@global array $config
 *	@return string Returns drivedb argument or empty string.
 */
function get_smartmontools_drivedb_arg() {
	global $config;

	arr::make_branch($config,'smartd');
	$drivedb_fqn = is_string($test = $config['smartd']['drivedb'] ?? '') ? $test : '';
	if(1 === preg_match('/\S/',$drivedb_fqn) && file_exists($drivedb_fqn)):
		return sprintf('--drivedb=%s ',escapeshellarg($drivedb_fqn));
	else:
		$cmd = 'sysrc -qn smartd_drivedb';
		$drivedb_fqn = mwexec2($cmd);
		if(1 === preg_match('/\S/',$drivedb_fqn) && file_exists($drivedb_fqn)):
			return sprintf('--drivedb=%s ',escapeshellarg($drivedb_fqn));
		endif;
	endif;
	return '';
}
/**
 *	Parse infos from camcontrol
 *	@param string $devtype ata, cdrom or scsi
 *	@return array devlist
 */
function parse_camcontrol_info(string $devtype) {
	$devlist = [];
	$controller = ['',''];
	$use_si = is_sidisksizevalues();
	$cmd = '/sbin/camcontrol devlist -v 2> /dev/null';
	unset($rawdata);
	mwexec2($cmd,$rawdata);
	foreach($rawdata as $rawline):
//		get controller
//		'scbus2 on mpt0 bus 0:' => 'mpt0'
		unset($matches);
		if(preg_match('/(?<= on )[-A-z0-9]*(?= bus )+/',$rawline,$matches)):
//			'mpt0' => 'mpt'
			$controller = preg_split('/([0-9]+\z)/i',$matches[0],-1,PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);
		elseif(!strncmp($rawline,'<>',2) == 0):
//			skip line '<>'
//			get target id
//			<VMware Virtual disk 1.0>          at scbus2 target 0 lun 0 (pass2,da0)
			unset($matches);
//			preg_match('/ target ([0-9]+) lun /',$rawline,$matches) would work as well
			if(preg_match('/(?<= target )[0-9]*(?= lun )+/',$rawline,$matches)):
				$target_id = $matches[0];
			else:
				$target_id = '';
			endif;
//			get lun id
			unset($matches);
			if(preg_match('/(?<= lun )[0-9]*/',$rawline,$matches)):
				$lun_id = $matches[0];
			else:
				$lun_id = '';
			endif;
//			get device string
//			parse substring between parentheses:
//			(pass0,da0) or (da0,pass0) => 'pass0,da0' or 'da0,pass0'
			unset($matches);
			preg_match('/.*\(([^>]*)\).*/',$rawline,$matches);
//			get device names
			$device = ['',''];
			$passthrough_device = ['',''];
			$a_device = explode(',',$matches[1]);
			$missing_device = true;
			$missing_passthrough_device = true;
			foreach($a_device as $r_device):
//				split device name into it's name and number
				$r_device_details = preg_split('/([-A-z]+)/',$r_device,-1,PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);
//				take only the first passthrough device and the first non-passthrough device
				if(0 === strncmp($r_device_details[0],'pass',4)):
					if($missing_passthrough_device):
						$passthrough_device = $r_device_details;
						$missing_passthrough_device = false;
						if($missing_device):
//							preset $device
							$device = $r_device_details;
						endif;
					endif;
				else:
					if($missing_device):
						$device = $r_device_details;
						$missing_device = false;
						if($missing_passthrough_device):
//							preset $passthroughdevice
							$passthrough_device = $r_device_details;
						endif;
					endif;
				endif;
			endforeach;
			if(preg_match('/\S/',$device[0])):
				$device_name = $device[0] . $device[1];
//				legacy compatibility: for scsi option, do not include ata drives, for ata option, do not include scsi drives
				if((($devtype != 'scsi' && $controller[0] == $devtype) || ($devtype == 'scsi' && $controller[0] != 'ata')) && $controller[0] != 'mfi'):
//					ignore empty, CD-ROM and SCSI enclosure devices (ses)
					if(!preg_match('/^(cd|acd|ses)/',$device[0])):
//						add device into devlice list array
						$devlist[$device_name]['device'] = $device[0];
						$devlist[$device_name]['id'] = $device[1];
						$devlist[$device_name]['name'] = $device_name;
						$devlist[$device_name]['devicespecialfile'] = '/dev/' . $device_name;
						$devlist[$device_name]['passthroughdevice'] = '/dev/' . $passthrough_device[0] . $passthrough_device[1];
						$devlist[$device_name]['passthroughdevice_id'] = $passthrough_device[1];
						init_device_attributes($devlist[$device_name]);
//						get diskinfo to get disk size
						$diskinfo = disks_get_diskinfo($devlist[$device_name]['devicespecialfile']);
						$devlist[$device_name]['size'] = isset($diskinfo['mediasize_bytes']) ? format_bytes($diskinfo['mediasize_bytes'],2,true,$use_si) : gtext('Unknown');
						$devlist[$device_name]['controller'] = $controller[0];
						$devlist[$device_name]['controller_id'] = $controller[1];
						$devlist[$device_name]['target_id'] = $target_id;
						$devlist[$device_name]['lun_id'] = $lun_id;
//						for backward compatibility
						switch($controller[0]):
							case 'ata':
								$devlist[$device_name]['type'] = 'IDE';
								break;
							case 'iscsi':
								$devlist[$device_name]['type'] = 'iSCSI';
								break;
							default:
								$devlist[$device_name]['type'] = 'SCSI';
								break;
						endswitch;
					endif;
				elseif($devtype == 'cdrom'):
//					display both SCSI and IDE cdroms
					if(preg_match('/^(cd|acd)/',$device[0])):
//						add device into device list array
						$devlist[$device_name]['device'] = $device[0];
						$devlist[$device_name]['id'] = $device[1];
						$devlist[$device_name]['name'] = $device_name;
						$devlist[$device_name]['devicespecialfile'] = '/dev/' . $device_name;
						$devlist[$device_name]['passthroughdevice'] = '/dev/' . $passthrough_device[0] . $passthrough_device[1];
						$devlist[$device_name]['passthroughdevice_id'] = $passthrough_device[1];
						init_device_attributes($devlist[$device_name]);
//						get diskinfo to get disk size
						$diskinfo = disks_get_diskinfo($devlist[$device_name]['devicespecialfile']);
						$devlist[$device_name]['size'] = isset($diskinfo['mediasize_bytes']) ? format_bytes($diskinfo['mediasize_bytes'],2,true,$use_si) : gtext('Unknown');
						$devlist[$device_name]['controller'] = $controller[0];
						$devlist[$device_name]['controller_id'] = $controller[1];
						$devlist[$device_name]['target_id'] = $target_id;
						$devlist[$device_name]['lun_id'] = $lun_id;
//						for backward compatibility
						switch($controller[0]):
							case 'ata':
								$devlist[$device_name]['type'] = 'IDE';
								break;
							case 'iscsi':
								$devlist[$device_name]['type'] = 'iSCSI';
								break;
							default:
								$devlist[$device_name]['type'] = 'SCSI';
								break;
						endswitch;
					endif;
				endif;
			endif;
		endif;
	endforeach;
	return $devlist;
}
/*
 *
 */
function parse_umass_controller_desc($controller_id) {
	$matches3 = [];
	mwexec2("dmesg | grep -w umass$controller_id",$lines);
	foreach($lines as $line):
//		example: umass0: <Corsair Voyager, class 0/0, rev 2.00/11.00, addr 2> on usbus7
		if(preg_match("/(?<=\> on )[a-z]+[0-9]+$/",$line,$matches)):
			mwexec2("dmesg | grep \"$matches[0] on \"",$lines2);
			foreach($lines2 as $line2):
//				example : usbus7 on ehci1
				if(preg_match("/(?<= on )[a-z]+[0-9]+$/",$line2,$matches2)):
					mwexec2("dmesg | grep \"$matches2[0]: <\"",$lines3);
//					example : ehci1: <Intel 82801JI (ICH10) USB 2.0 controller USB-A> mem 0xfdffe000-0xfdffe3ff irq 23 at device 29.7 on pci0
					foreach($lines3 as $line3):
						if(preg_match("/(?<=: \<).*(?=\> )+/",$line3,$matches3)):
							return $matches3[0];
						endif;
					endforeach;
				endif;
			endforeach;
		endif;
	endforeach;
	return $matches3[0];
}
function parse_umass_controller(&$device) {
	global $config;

	$output = '';
	$searchresult = '';
	$smartd_drivedb_arg = get_smartmontools_drivedb_arg();

	$device['model'] = parse_device_desc($device['name']);
	$device['controller_desc'] = parse_umass_controller_desc($device['controller_id']);

	$devicefilepath = sprintf('/dev/%s',$device['name']);

	$device['smart']['devicefilepath'] = $devicefilepath;
	$device['smart']['devicetype'] = '';
	$device['smart']['devicetypearg'] = '';

	$cmd = sprintf('smartctl ' . $smartd_drivedb_arg . '-d test %s',escapeshellarg($devicefilepath));
	mwexec2($cmd,$output);
	foreach($output as $row):
		if(1 === preg_match("/Device of type '(.*)' \[.*\] opened/i",$row,$searchresult)):
//			supported by smartmontools, leave args empty
//			$device['smart']['devicetype'] = $searchresult[1];
//			$device['smart']['devicetypearg'] = $searchresult[1];
			break;
		elseif(1 === preg_match('/Unknown USB bridge (\[.*\])/i',$row,$searchresult)):
//			unknown to smartmontools, take $searchresult to lookup additional configuration
//			if no version is provided the usb id is returned using format [0x%04x:0x%04x],vendor_id,product_id
//			if version exists the usb id is returned using format [0x%04x:0x%04x (0x%03x)],vendor_id,product_id,version
			$name = $searchresult[1];
			$a_param = &arr::make_branch($config,'smartmontools','umass','param');
			$key = arr::search_ex($name,$a_param,'name');
			if($key !== false):
				$is_enabled = isset($a_param[$key]['enable']) && (is_bool($a_param[$key]['enable']) ? $a_param[$key]['enable'] : true);
				if($is_enabled):
					$value = $a_param[$key]['type'] ?? '';
					$device['smart']['devicetype'] = $value;
					$device['smart']['devicetypearg'] = $value;
				endif;
			endif;
			break;
		endif;
	endforeach;
	return true;
}
/*
 *	Parse controller dependent info
 */
function parse_controller_config(&$devlist) {
	global $config_disks;

	$smartd_drivedb_arg = get_smartmontools_drivedb_arg();
	foreach($devlist as &$device):
		$devtype = '';
		$device['desc'] = $config_disks[$device['name']]['desc'] ?? '';
		switch($device['controller']):
			case 'arcmsr':
//				Experimental : requires arcmsr to add enclosure support
//				Areca SATA[/SAS] RAID controller
//				SMART Device type format : areca,N/E (N = channel (slot), E = enclosure)
//				smartctl -a -d areca,9/2 /dev/arcmsr0
				$device['controller_desc'] = parse_raid_controller_desc($device['controller'] . $device['controller_id']);
				$device['smart']['devicefilepath'] = '/dev/' . $device['controller'] . $device['controller_id'];
				$device['smart']['devicetype'] = 'areca';
				$device['smart']['devicetypearg'] = 'areca,' . ($device['target_id']+1);
				break;
			case 'ahcich':
			case 'ata':
				$device['model'] = parse_device_desc($device['name']);
				$device['controller_desc'] = parse_ata_ahci_controller_desc($device['controller'] . $device['controller_id']);
				mwexec2('smartctl ' . $smartd_drivedb_arg . '-d test ' . '/dev/' . $device['name'] . " | grep \" opened\" | xargs -0 -J {} expr {} : \".*Device of type '\(.*\)' \[.*\] opened\"",$devtype);
				$device['smart']['devicefilepath'] = '/dev/'.$device['name'];
				$device['smart']['devicetype'] = $devtype[0];
				$device['smart']['devicetypearg'] = $devtype[0];
				break;
			case 'ciss':
//				HP Smart Array controller
//				SMART Device type format : cciss,N (N = which disk on the controller is monitored)
//				e.g. smartctl -d cciss,1 -a /dev/ciss0
				$devicetype = 'cciss';
				$device['controller_desc'] = parse_raid_controller_desc($device['controller'].$device['controller_id']);
				$device['smart']['devicefilepath'] = '/dev/' . $device['controller'] . $device['controller_id'];
				$device['smart']['devicetype'] = $devicetype;
				if(preg_match('/\S/',$device['passthroughdevice_id'])):
					$device['smart']['devicetypearg'] = sprintf('%s,%s',$devicetype,$device['passthroughdevice_id']);
				else:
					$device['smart']['devicetypearg'] = sprintf('%s,%s',$devicetype,$device['target_id']);
				endif;
				break;
			case 'hptiop':
//				HighPoint RocketRAID 3xxx/4xxx device driver
			case 'hptmv':
//				HighPoint RocketRAID 182x device driver
			case 'hptrr':
//				HighPoint RocketRAID device driver
			case 'hpt27xx':
//				Highpoint RocketRAID 27xx controller
				$controller_id = $device['controller_id'] + 1;
				$disk_id = $device['target_id']+1;
				$device['controller_desc'] = parse_raid_controller_desc($device['controller'] . $device['controller_id']);
				$device['smart']['devicefilepath'] = '/dev/' . $device['controller'];
				$device['smart']['devicetype'] = $device['controller'];
				$device['smart']['devicetypearg'] = 'hpt,' . $controller_id . '/' . $disk_id;
				break;
			case 'mfi':
//				LSI MegaRAID SAS
				$mfi_device = map_mfi_device_name($device['controller'] . $device['controller_id'],$device['name']);
				$device['target_id'] = $mfi_device['target_id'];
				$device['model'] = parse_device_desc($mfi_device['device_name']);
				$device['controller_desc'] = parse_raid_controller_desc($device['controller'] . $device['controller_id']);
				$device['smart']['devicefilepath'] = '/dev/' . $mfi_device['device_name'];
				$device['smart']['devicetype'] = 'sat';
				$device['smart']['devicetypearg'] = 'sat';
				break;
			case 'mps':
//				LSI 2008 (IT mode)
			case 'mpt':
				$device['model'] = parse_device_desc($device['name']);
				$device['controller_desc'] = parse_device_desc($device['controller'] . $device['controller_id']);
				mwexec2('smartctl ' . $smartd_drivedb_arg . '-d test /dev/' . $device['name'] . " | grep \" opened\" | xargs -0 -J {} expr {} : \".*Device of type '\(.*\)' \[.*\] opened\"",$devtype);
				$device['smart']['devicefilepath'] = '/dev/' . $device['name'];
				$device['smart']['devicetype'] = $devtype[0];
				$device['smart']['devicetypearg'] = $devtype[0];
				break;
			case 'nvme':
				$controller_fqn = $device['controller'] . $device['controller_id'];
				$device['model'] = parse_device_desc($device['name']);
				$device['controller_desc'] = parse_device_desc($controller_fqn);
				mwexec2('smartctl ' . $smartd_drivedb_arg . '-d test /dev/' . $controller_fqn . " | grep \" opened\" | xargs -0 -J {} expr {} : \".*Device of type '\(.*\)' \[.*\] opened\"",$devtype);
				$device['smart']['devicefilepath'] = '/dev/' . $controller_fqn;
				$device['smart']['devicetype'] = $devtype[0];
				$device['smart']['devicetypearg'] = $devtype[0];
				unset($controller_fqn);
				break;
			case 'twa':
//				3ware 9000/9500/9550/9650 series SATA RAID controller
			case 'twe':
//				3ware 5000/6000/7000/8000 series PATA/SATA RAID adapter
				$device['controller_desc'] = parse_raid_controller_desc($device['controller'] . $device['controller_id']);
				$device['smart']['devicefilepath'] = '/dev/' . $device['controller'] . $device['controller_id'];
				$device['smart']['devicetype'] = '3ware';
				$tw_line = [];
				$port = 0;
				$port_num = [];
				mwexec2('/usr/local/sbin/tw_cli /c' . $device['controller_id'] . '/u' . $device['target_id'] . ' show | grep -E "^u"',$tw_line);
				if(preg_match('/(?<=p)[\d]+/',$tw_line[0],$port_num)):
					$port = $port_num[0];
				endif;
				$device['smart']['devicetypearg'] = '3ware,' . $port;
				break;
			case 'umass-sim':
//				USB Mass Storage
				parse_umass_controller($device);
				break;
			default:
//				auto detect devices to cater for SATA disks pass through via HBA (non-RAID) (such as LSI SAS2008 RAID controller (e.g. IBM ServeRAID M1015) flashed to LSI9211-IT firmware)
				$device['model'] = parse_device_desc($device['name']);
				$device['controller_desc'] = parse_device_desc($device['controller'] . $device['controller_id']);
				mwexec2('smartctl ' . $smartd_drivedb_arg . '-d test /dev/' . $device['name'] . " | grep \" opened\" | xargs -0 -J {} expr {} : \".*Device of type '\(.*\)' \[.*\] opened\"",$devtype);
				$device['smart']['devicefilepath'] = '/dev/' . $device['name'];
				$device['smart']['devicetype'] = $devtype[0];
				$device['smart']['devicetypearg'] = $devtype[0];
				break;
		endswitch;
//		parse info from S.M.A.R.T.
		$smartctl_info = get_smartctl_info($device);
		if(!empty($smartctl_info['desc'])):
			$device['desc'] = $smartctl_info['desc'];
		endif;
		if(!empty($smartctl_info['model'])):
			$device['model'] = $smartctl_info['model'];
		endif;
		if(!empty($smartctl_info['serial'])):
			$device['serial'] = $smartctl_info['serial'];
		endif;
		if(!empty($smartctl_info['rotation_rate'])):
			$device['rotation_rate'] = $smartctl_info['rotation_rate'];
		endif;
		if(!empty($smartctl_info['transfer_rate'])):
			$device['transfer_rate'] = $smartctl_info['transfer_rate'];
		endif;
//		if S.M.A.R.T. is not available, get transfer speed from dmesg
		if(empty($smartctl_info['transfer_rate'])):
			mwexec2('dmesg | grep "' . $device['name'] . ': " | grep "transfers"',$lines);
			foreach($lines as $line):
				$matches = preg_split("/[\s\:]+/",$line);
				if(strcmp($matches[0],$device['name']) == 0 && strcmp($matches[2],'transfers') == 0):
					$device['transfer_rate'] = $matches[1];
				endif;
			endforeach;
		endif;
		if(!empty($smartctl_info['smart_support'])):
			$device['smart']['smart_support'] = $smartctl_info['smart_support'];
		else:
			$device['smart']['smart_support'] = 'Unavailable';
		endif;
		if(!empty($smartctl_info['isavailable'])):
			$device['smart']['isavailable'] = $smartctl_info['isavailable'];
		endif;
		if(!empty($smartctl_info['isenabled'])):
			$device['smart']['isenabled'] = $smartctl_info['isenabled'];
		endif;
//		retry empty case
		if(empty($device['model'])):
			$device['model'] = system_get_volume_model($device['devicespecialfile']);
		endif;
		if(empty($device['desc'])):
			$device['desc'] = $device['model'];
		endif;
		if(empty($device['serial'])):
			$device['serial'] = system_get_volume_serial($device['devicespecialfile']);
		endif;
//		final fixup
		$device['model'] = str_replace('"','',$device['model']);
		$device['desc'] = str_replace('"','',$device['desc']);
		$device['serial'] = str_replace('"','',$device['serial']);
	endforeach;
	unset($device);
	return $devlist;
}
/*
 *
 */
function map_mfi_device_name($controller,$mfisyspd) {
	$mfi_device = [];
	mwexec2("dmesg | grep \"" . $device['controller'] . "\"",$lines);
//	look for deviceid '0' in mfisyspd0: 3815447MB (7814037168 sectors) SYSPD volume (deviceid: 0)
	foreach($lines as $line):
		if(preg_match("/^" . $mfisyspd . ": /",$line,$matches)):
			if(preg_match("/(?<= \(deviceid: )[0-9]+/",$line,$matches)):
				$mfi_device['target_id'] = $matches[0];
			endif;
		endif;
	endforeach;
//	2nd pass to retrieve actual device name
	foreach($lines as $line):
		if(preg_match("/[-A-z0-9].*(?= at " . $controller . " [-A-z0-9 ].*(?=target " . $mfi_device['target_id'] . "))+/",$line,$matches)):
			$mfi_device['device_name'] = $matches[0];
		endif;
	endforeach;
	return $mfi_device;
}
/*
 *	Parse info from S.M.A.R.T.
 */
function get_smartctl_info($device) {
	$smartctl_info = [];
	$type_arg = '';
	$vendor = '';
	$product = '';
	$revision = '';
	$smartd_drivedb_arg = get_smartmontools_drivedb_arg();
	if(!empty($device['smart']['devicetypearg'])):
		$type_arg = sprintf('-d %s ',$device['smart']['devicetypearg']);
	endif;
	mwexec2('smartctl ' . $smartd_drivedb_arg . '-i ' . $type_arg . $device['smart']['devicefilepath'],$lines);
	foreach($lines as $line):
//		trim and convert token to lowercase
		$str_startswith = strtolower(trim(substr($line,0,18)));
		$matches = [];
		switch($str_startswith):
//			compare always to lowercase and trimmed keywords
			case 'model family:':
				preg_match("/(?<=model family:).*/i",$line,$matches);
				$smartctl_info['desc'] = trim($matches[0]);
				break;
			case 'device model:':
			case 'model number:':
				preg_match("/(?<=(device model:|model number:)).*/i",$line,$matches);
				$smartctl_info['model'] = trim($matches[0]);
				break;
			case 'vendor:':
				preg_match("/(?<=vendor:).*/i",$line,$matches);
				$vendor = trim($matches[0]);
				break;
			case 'revision:':
				preg_match("/(?<=revision:).*/i",$line,$matches);
				$revision = trim($matches[0]);
				break;
			case 'product:':
				preg_match("/(?<=product:).*/i",$line,$matches);
				$product = trim($matches[0]);
				break;
			case 'serial number:':
				preg_match("/(?<=serial number:).*/i",$line,$matches);
				$smartctl_info['serial'] = trim($matches[0]);
				break;
			case 'rotation rate:':
				preg_match("/(?<=rotation rate:).*/i",$line,$matches);
				$smartctl_info['rotation_rate'] = trim($matches[0]);
				break;
			case 'sata version is:':
				if(preg_match("/(?<= \(current:).*(?=\))+/i",$line,$matches)):
					$smartctl_info['transfer_rate'] = trim($matches[0]);
				elseif(preg_match("/(?<=, ).*?(?>\/s)/i",$line,$matches)):
					$smartctl_info['transfer_rate'] = trim($matches[0]);
				endif;
				break;
			case 'smart support is:':
				if(empty($smartctl_info['smart_support'])):
					if(preg_match("/(?<=smart support is:).*(?=\-)+/i",$line,$matches)):
						$smartctl_info['smart_support'] = ltrim($matches[0]);
						$smartctl_info['isavailable'] = strncasecmp(trim($matches[0]),'available',9) == 0;
					endif;
				else:
					if(strncasecmp($smartctl_info['smart_support'],"available",9) == 0):
						if(preg_match("/(?<=smart support is: ).*/i",$line,$matches)):
							$smartctl_info['smart_support'] = $smartctl_info['smart_support'] . ', ' . $matches[0];
							$smartctl_info['isenabled'] = strncasecmp(trim($matches[0]),'enabled',7) == 0;
						endif;
					endif;
				endif;
				break;
		endswitch;
	endforeach;
//	set model to vendor,product,revision
	if(empty($smartctl_info['model'])):
		$smartctl_info['model'] = trim($vendor . ' ' . $product . ' ' . $revision);
 	endif;
//	final fixup
	$smartctl_info['model'] = str_replace('"','',isset($smartctl_info['model']) ? $smartctl_info['model'] : '');
	$smartctl_info['desc'] = str_replace('"','',isset($smartctl_info['desc']) ? $smartctl_info['desc'] : '');
	$smartctl_info['serial'] = str_replace('"','',isset($smartctl_info['serial']) ? $smartctl_info['serial'] : '');
	return $smartctl_info;
}
/*
 *
 */
function init_device_attributes(&$device) {
	$device['desc'] = '';
	$device['model'] = '';
	$device['serial'] = '';
	$device['type'] = '';
	$device['size'] = '';
	$device['rotation_rate'] = '';
	$device['transfer_rate'] = '';
	$device['controller'] = '';
	$device['controller_id'] = '';
	$device['controller_desc'] = '';
	$device['target_id'] = '';
	$device['lun_id'] = '';
	$device['smart']['devicefilepath'] = '';
	$device['smart']['devicetype'] = '';
	$device['smart']['devicetypearg'] = '';
	$device['smart']['smart_support'] = '';
	$device['smart']['isavailable'] = false;
	$device['smart']['isenabled'] = false;
}
/*
 *
 */
function parse_device_desc($device) {
	$matches = [];
//	device order may change, so take latest(last) line
	mwexec2("dmesg | grep \"^$device: <\" | tail -r",$lines);
	foreach($lines as $line):
//		example: da2: <Corsair Voyager 1100> Removable Direct Access SCSI-0 device
		if(preg_match("/(?<=\<).*(?=\>)+/",$line,$matches)):
			return $matches[0];
		endif;
	endforeach;
	return '';
}
/*
 *
 */
function parse_ata_ahci_controller_desc($controller) {
	$controller_desc = '';
	mwexec2("dmesg | grep -w $controller: | sort -u | uniq",$lines);
	foreach($lines as $line):
//		example : ahcich2: <AHCI channel> at channel 2 on ahci0
		if(preg_match("/(?<= on )[a-z]+[0-9]+$/",$line,$matches)):
			mwexec2("dmesg | grep -w $matches[0]: | sort -u | uniq",$lines2);
			foreach($lines2 as $line2):
//				example : ahci0: <Intel ICH10 AHCI SATA controller> port 0xf900-0xf907,0xf800-0xf803,0xf700-0xf707,0xf600-0xf603,0xf500-0xf51f mem 0xfdffd000-0xfdffd7ff irq 19 at device 31.2 on pci0
				if(preg_match("/(?<=: \<).*(?=\> )+/",$line2,$matches2)):
					if(strncmp($controller_desc,'',1)==0):
						$controller_desc = $matches2[0];
					else:
						$controller_desc = $controller_desc . ', ' . $matches2[0];
					endif;
				endif;
			endforeach;
		endif;
	endforeach;
	return $controller_desc;
}
/*
 *
 */
function parse_raid_controller_desc($controller) {
	$matches = [];
	if(strncmp($line,$controller ,4)):
		mwexec2("dmesg | grep $controller",$lines);
		foreach($lines as $line):
			if(strncmp($line,$controller . ': <' ,strlen($controller)+3) == 0):
				if(preg_match("/(?<=\<).*(?=\>)|(?<=\<).*(?=$)/",$line,$matches)):
					return $matches[0];
				endif;
			endif;
		endforeach;
	endif;
	return $matches[0];
}
/*
 *	Get list of ATA disks.
 */
function get_ata_disks_list() {
	$devlist = [];
	$devlist = parse_camcontrol_info('ata');
	$devlist = parse_controller_config($devlist);
	return $devlist;
}
/*
 *	Get list of IDE AND SCSI CDROM.
 */
function get_cdrom_list() {
	$devlist = [];
	$devlist = parse_camcontrol_info('cdrom');
	$devlist = parse_controller_config($devlist);
	return $devlist;
}
/*
 *	Get list of SCSI disks.
 */
function get_scsi_disks_list() {
	$devlist = [];
	$devlist = parse_camcontrol_info('scsi');
	$devlist = parse_controller_config($devlist);
	return $devlist;
}
/*
 *
 */
function get_iscsi_disks_list() {
	$disklist = [];
	$use_si = is_sidisksizevalues();
//	get all devlist w/bus
	exec('/sbin/camcontrol devlist -v',$rawdata);
	$iscsi = false;
	foreach($rawdata as $line):
//		iscsi bus?
		if(preg_match("/^scbus([-\d]+)\s+on\s+iscsi\d+\s+/",$line)):
			$iscsi = true;
			continue;
		elseif(preg_match("/^[^<]/",$line)):
			continue;
		endif;
		if(!$iscsi):
			continue;
		endif;
//		get information include between parenthese: (pass0,da0) or (da0,pass0)
		preg_match("/.*\(([^>]*)\).*/",$line,$match);
		if($match[1] == ''):
			$iscsi = false;
			continue;
		endif;
//		spare le resultat par la virgule
		$temp = preg_split('/,/',$match[1]);
//		check if diskname is the first (da0,pass0) or the second (pass0,da0) arguement
		$diskname = $temp[1];
		if($diskname[0] === 'p'):
			$diskname = $temp[0];
		endif;
//		on exlus les lecteurs cd
		if(!preg_match('/^(cd)/',$diskname)):
			$disklist[$diskname] = [];
			$disklist[$diskname]['name'] = $diskname;
			$disklist[$diskname]['devicespecialfile'] = '/dev/' . $diskname;
			$disklist[$diskname]['type'] = 'iSCSI';
//			match the description which is include between < and >
			preg_match('/.*\<([^>]*)>.*/',$line,$match);
			$disklist[$diskname]['desc'] = $match[1];
//			get diskinfo to get disk size
			$diskinfo = disks_get_diskinfo($diskname);
			$disklist[$diskname]['size'] = isset($diskinfo['mediasize_bytes']) ? format_bytes($diskinfo['mediasize_bytes'],2,true,$use_si) : gtext('Unkown');
//			get serial number
			$serial = system_get_volume_serial('/dev/' . $diskname,$disklist[$diskname]['controller']);
			$disklist[$diskname]['serial'] = $serial;
		endif;
	endforeach;
	return $disklist;
}
/*
 *	Get list of hardware RAID disks.
 *	[aacd0] => [
 *		[type] => RAID
 *		[desc] => XYZ
 *		[size] => xxxMB
 *		[name] => aacd0
 *		[devicespecialfile] => /dev/aacd0
 *		[serial] => XX123456
 *	]
 */
function get_hraid_disks_list() {
	$disklist = [];
	$use_si = is_sidisksizevalues();
//	recupere la liste des disques RAID
	$kerneldisks = explode(' ',trim(preg_replace('/kern.disks: /','',exec('/sbin/sysctl kern.disks'))));
//	recupere la liste des disques ATA et SCSI
	$diskdetected = array_merge((array)get_ata_disks_list(),(array)get_scsi_disks_list());
//	recupere le dmesg
	exec('/sbin/dmesg',$rawdmesg);
	foreach($kerneldisks as $diskname):
		$allready = 1;
//		check of this entry is IDE or SCSI (allready detected)
		foreach($diskdetected as $diskfoundk => $diskfoundv):
			if(strcasecmp($diskfoundk,$diskname) == 0):
				$allready = 0;
			endif;
		endforeach;
//		exclude cdrom device
		if(preg_match('/^(cd)/',$diskname)):
			$allready = 0;
		endif;
		if($allready):
//			if not an IDE and SCSI disk
			$device = [];
			$device = preg_split('/([-A-z]+)/',$diskname,-1,PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);
			$disklist[$diskname]['name'] = $diskname;
			$disklist[$diskname]['id'] = $device[1];
			init_device_attributes($disklist[$diskname]);
			$disklist[$diskname]['devicespecialfile']= '/dev/' . $diskname;
			$disklist[$diskname]['type'] = 'RAID';
			if($device[0] == 'twed' || $device[0] == 'mfisyspd'):
				if($device[0] == 'twed'):
					$disklist[$diskname]['target_id'] = $disklist[$diskname]['id'];
				endif;
				$matches = [];
//				look for controller details from dmesg
				foreach($rawdmesg as $line):
//					example : twed2 on twe0
					if(preg_match('/(?<=' . $diskname . ' on )[a-z]+[0-9]+$/',$line,$matches)):
						$controller = [];
						$controller = preg_split('/([-A-z]+)/',$matches[0],-1,PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);
//						get controller and controller id
						$disklist[$diskname]['controller'] = $controller[0];
						$disklist[$diskname]['controller_id'] = $controller[1];
					endif;
				endforeach;
			else:
//				looking for the disk description in the dmesg
				foreach($rawdmesg as $dmesgline):
//					separe la ligne par les espace
					$dmesgtab = explode(' ',$dmesgline);
					$dmesgtab[0] = rtrim($dmesgtab[0],':');
//					si la ligne commence par le nom du disque: attention il y a 2 lignes
					if($dmesgtab[0] != '' && (strcasecmp($dmesgtab[0],$diskname) == 0)):
//						the first line as this example "aacd0: <RAID 5> on aac0"
						if(strcasecmp(substr($dmesgtab[1],0,1),'<') == 0):
//							match the description witch is include between < and >
							preg_match('/.*\<([^>]*)>.*/',$dmesgline,$match);
							$disklist[$diskname]['desc'] = $match[1];
						endif;
					endif;
				endforeach;
			endif;
//			get diskinfo to get disk size
			$diskinfo = disks_get_diskinfo($diskname);
			$disklist[$diskname]['size'] = isset($diskinfo['mediasize_bytes']) ? format_bytes($diskinfo['mediasize_bytes'],2,true,$use_si) : gtext('Unknown');
//			get serial number
			$serial = system_get_volume_serial('/dev/' . $diskname,$disklist[$diskname]['controller']);
			$disklist[$diskname]['serial'] = $serial;
		endif;
	endforeach;
	$disklist = parse_controller_config($disklist);
	return $disklist;
}
/*
 *	Return list of ALL disk: physical, hardware RAID, Software RAID disk and HAST disk
 */
function get_physical_disks_list() {
	$disklist = array_merge((array)get_ata_disks_list(),(array)get_scsi_disks_list(),(array)get_hraid_disks_list(),(array)get_hast_disks_list());
	return $disklist;
}
/*
 *	Return list of ALL disk: physical, hardware RAID and Software RAID disk
 */
function get_all_disks_list() {
	$disklist = array_merge((array)get_ata_disks_list(),(array)get_scsi_disks_list(),(array)get_hraid_disks_list(),(array)get_sraid_disks_list());
	return $disklist;
}
/*
 *	Wrapper for exec().
 *	$command - Command to be executed.
 *	$logerr - Write error messages to log file.
 */
function mwexec($command,$logerr = false) {
	global $g;

	if($g['debug']):
		if(!$_SERVER['REMOTE_ADDR']):
			echo "mwexec(): $command\n";
		endif;
		passthru($command,$retval);
	else:
		$redirect = ">/dev/null 2>&1";
		if($logerr === true):
			$redirect = "2>&1 >/dev/null";
		endif;
		exec("{$command} {$redirect}",$output,$retval);
		if(($logerr === true) && (is_array($output))):
			write_log(implode("\n",$output));
		endif;
	endif;
	return $retval;
}
/*
 *
 */
function mwexec2($command,&$output = null,&$return_var = null) {
	return exec($command,$output,$return_var);
}
/*
 *	wrapper for exec() in background
 */
function mwexec_bg($command) {
	global $g;

	if($g['debug']):
		if(!$_SERVER['REMOTE_ADDR']):
			echo "mwexec(): $command\n";
		endif;
	endif;
	exec("nohup $command > /dev/null 2>&1 &");
}
/*
 *	unlink a file, if it exists
 */
function unlink_if_exists($fqfn) {
	if(file_exists($fqfn)):
		unlink($fqfn);
	endif;
}
/*
 *	compare two IP addresses
 */
function ipcmp($a,$b) {
	return(ip2long($a) <=> ip2long($b));
}
/*
 *	return true if $addr is in $subnet, false if not
 */
function ip_in_subnet($addr,$subnet) {
	[$ip,$mask] = explode('/',$subnet);
	$mask = 0xffffffff << (32 - $mask);
	return((ip2long($addr) & $mask) == (ip2long($ip) & $mask));
}
/*
 *	Get the interface name
 */
function get_ifname($if) {
//	check if 'auto' mode is activated
	if($if === 'auto'):
		$interfaces = explode(' ',exec('/sbin/ifconfig -l'));
		foreach($interfaces as $ifname):
			if(!preg_match("/^(ppp|sl|gif|faith|lo|vlan|tun|plip|ipfw|usbus|carp)/",$ifname)):
				$if = $ifname;
				break;
			endif;
		endforeach;
		if($if === 'auto'):
			$if = 'lo0';
		endif;
	endif;
	return $if;
}
/*
 *	Get local IPv4 address
 */
function get_ipaddr($if) {
	$if = get_ifname($if);
	unset($ipaddr);
	exec("/sbin/ifconfig {$if} inet | /usr/bin/grep inet | /usr/bin/grep -v vhid",$inetinfo);
	$inet = $inetinfo[0] ?? '';
	$ainet = preg_split('/\s+/',ltrim($inet));
	$ipaddr = rtrim($ainet[1] ?? '');
	if(!empty($ipaddr)):
		return $ipaddr;
	endif;
	exec("/usr/bin/netstat -inW -f inet -I {$if}",$inetinfo);
	array_shift($inetinfo);
	foreach($inetinfo as $inet):
		$ainet = preg_split('/\s+/',ltrim($inet));
		$ifname = chop($ainet[0]);
		if(strncmp($ifname,$if,strlen($if)) == 0):
			$ipaddr = chop($ainet[3]);
			break;
		endif;
	endforeach;
	return !empty($ipaddr) ? $ipaddr : null;
}
/*
 *	Get subnet bits.
 */
function get_subnet_bits($if) {
	$if = get_ifname($if);
	exec("/sbin/ifconfig {$if} inet | /usr/bin/grep inet | /usr/bin/grep -v vhid",$inetinfo);
	$inet = $inetinfo[0] ?? '';
	$ainet = preg_split('/\s+/',ltrim($inet));
	$ipaddr = rtrim($ainet[1] ?? '');
	$mask = rtrim($ainet[3] ?? '');
	if(!empty($ipaddr) && !empty($mask)):
		exec("/usr/local/bin/sipcalc $ipaddr $mask",$rawdata);
		if(preg_match("/.+Network mask \(bits\)	- (\d+).+/",implode($rawdata),$matches)):
			return $matches[1];
		endif;
	endif;
	exec("/usr/local/bin/sipcalc --cidr-addr {$if}",$rawdata);
	if(preg_match('/.+Network mask \(bits\)	- (\d+).+/',implode($rawdata),$matches)):
		return $matches[1];
	endif;
	return false;
}
/*
 *	Get local IPv6 address
 */
function get_ipv6addr($if) {
	$if = get_ifname($if);
	unset($ipaddr);
	exec("/sbin/ifconfig {$if} inet6",$rawdata);
	foreach($rawdata as $line):
		if(preg_match('/^\s+inet6\s+(\S+)\s/',$line,$m)):
			$ipaddr = $m[1];
		endif;
	endforeach;
	if(!empty($ipaddr)):
		return $ipaddr;
	endif;
	exec("/usr/bin/netstat -inW -f inet6 -I {$if}",$inetinfo);
	array_shift($inetinfo);
	foreach($inetinfo as $inet):
		$ainet = preg_split('/\s+/',ltrim($inet));
		$ifname = chop($ainet[0]);
		if(strncmp($ifname,$if,strlen($if)) == 0):
			$ipaddr = chop($ainet[3]);
			break;
		endif;
	endforeach;
	return !empty($ipaddr) ? $ipaddr : null;
}
/*
 *	Get local MAC address
 */
function get_macaddr($if) {
	$if = get_ifname($if);
	unset($macaddr);
	exec("/usr/bin/netstat -inW -f link -I {$if}",$linkinfo);
	array_shift($linkinfo);
	foreach($linkinfo as $link):
		$alink = preg_split('/\s+/',ltrim($link));
		$ifname = chop($alink[0]);
		if(strncmp($ifname,$if,strlen($if)) == 0):
			$macaddr = chop($alink[3]);
			break;
		endif;
	endforeach;
	return !empty($macaddr) ? $macaddr : null;
}
/*
 *	Get DNS servers.
 *	Parse /etc/resolv.conf when using DHCP (will be updated
 *	when 'dhclient' is executed), otherwise use configured
 *	DNS servers from config.xml for static IP.
 *	Returns array of DNS servers.
 */
function get_ipv4dnsserver() {
	global $config;

	$result = [];
	switch($config['interfaces']['lan']['ipaddr']):
		case 'dhcp':
			exec('cat /etc/resolv.conf',$rawdata);
			foreach($rawdata as $data):
				$adata = preg_split('/\s+/',$data);
				if(strcmp(strtolower(trim($adata[0])),'nameserver') == 0):
					if(is_ipv4addr(trim($adata[1]))):
						$result[] = trim($adata[1]);
					endif;
				endif;
			endforeach;
			break;
		default:
			if(isset($config['system']['dnsserver'])):
				$result = $config['system']['dnsserver'];
			endif;
			break;
	endswitch;
	$result = array_merge($result,['','']);
	return $result;
}
/*
 *
 */
function get_ipv6dnsserver() {
	global $config;

	$result = [];
	switch($config['interfaces']['lan']['ipv6addr']):
		case 'auto':
			exec('cat /etc/resolv.conf',$rawdata);
			foreach($rawdata as $data):
				$adata = preg_split('/\s+/',$data);
				if(strcmp(strtolower(trim($adata[0])),'nameserver') == 0):
					if(is_ipv6addr(trim($adata[1]))):
						$result[] = trim($adata[1]);
					endif;
				endif;
			endforeach;
			break;
		default:
			$result = $config['system']['ipv6dnsserver'];
			break;
	endswitch;
	$result = array_merge($result,['','']);
	return $result;
}
/**
 *	Returns the default IPv4 gateway or an empty string if it doesn't exist
 *	@global array $config
 *	@return string
 */
function get_ipv4defaultgateway(): string {
	global $config;

	$result = '';
	$gateway_found = false;
	$config_lan = arr::make_branch($config,'interfaces','lan');
//	if(!gateway_found):
		if(isset($config_lan['ipaddr']) && ($config_lan['ipaddr'] == 'dhcp')):
			$cmd = 'netstat -4rnW --libxo:J';
			$json_string = shell_exec($cmd);
			$rawdata = json_decode($json_string,true);
			$rt_entries = arr::make_branch($rawdata,'statistics','route-information','route-table','rt-family','rt-entry');
			foreach($rt_entries as $rt_entry):
				$destination = $rt_entry['destination'] ?? null;
				if($destination == 'default'):
					$test = $rt_entry['gateway'] ?? null;
					if(is_scalar($test)):
						$result = $test;
						$gateway_found = true;
					endif;
					break;
				endif;
			endforeach;
		endif;
//	endif;
	if(!$gateway_found):
		$test = $config_lan['gateway'] ?? null;
		if(is_scalar($test)):
			$result = $test;
//			$gateway_found = true;
		endif;
	endif;
	return $result;
}
/**
 *	Returns the default IPv6 gateway or en empty string if it doesn't exist
 *	@global array $config
 *	@return string
 */
function get_ipv6defaultgateway(): string {
	global $config;

	$result = '';
	$gateway_found = false;
	$config_lan = arr::make_branch($config,'interfaces','lan');
//	if(!gateway_found):
		if(isset($config_lan['ipv6addr']) && ($config_lan['ipv6addr'] == 'auto')):
			$cmd = 'netstat -6rnW --libxo:J';
			$json_string = shell_exec($cmd);
			$rawdata = json_decode($json_string,true);
			$rt_entries = arr::make_branch($rawdata,'statistics','route-information','route-table','rt-family','rt-entry');
			foreach($rt_entries as $rt_entry):
				$destination = $rt_entry['destination'] ?? null;
				if($destination == 'default'):
					$test = $rt_entry['gateway'] ?? null;
					if(is_scalar($test)):
						$result = $test;
						$gateway_found = true;
					endif;
					break;
				endif;
			endforeach;
		endif;
//	endif;
	if(!$gateway_found):
		$test = $config_lan['ipv6gateway'] ?? null;
		if(is_scalar($test)):
			$result = $test;
//			$gateway_found = true;
		endif;
	endif;
	return $result;
}
/*
 *	Get list of supported filesystem types
 */
function get_fstype_list() {
	global $g_filesystems;

	return $g_filesystems;
}
/*
 *
 */
function get_fstype_shortdesc($fstype) {
	$shortdesc = '';
	switch($fstype):
		case '':
			$shortdesc = gtext('Unformated');
			break;
		case 'ufs':
		case 'ufs_no_su':
		case 'ufsgpt':
		case 'ufsgpt_no_su':
			$shortdesc = 'UFS';
			break;
		case 'msdos':
			$shortdesc = 'FAT32';
			break;
		case 'cd9660':
			$shortdesc = 'CD/DVD';
			break;
		case 'ntfs':
			$shortdesc = 'NTFS';
			break;
		case 'gmirror':
		case 'gconcat':
		case 'gstripe':
		case 'gvinum':
			$shortdesc = $fstype;
			break;
		case 'softraid':
			$shortdesc = gtext('SoftRaid');
			break;
		case 'geli':
			$shortdesc = gtext('Encrypted');
			break;
		case 'ext2':
			$shortdesc = 'EXT2/3/4';
			break;
		case 'exfat':
			$shortdesc = 'exFAT';
			break;
		case 'zfs':
			$shortdesc = 'ZFS Storage Pool';
			break;
	endswitch;
	return $shortdesc;
}
/*
 *	Get interface information.
 *	$if - Interface name (e.g. re0, ...)
 *	Result: Array
 *	(
 *		[hwif] => re0
 *		[if] => re0
 *		[status] => up
 *		[mtu] = 1500
 *		[macaddr] => 00:0e:2e:0a:62:75
 *		[inpkts] => 367
 *		[inerrs] => 0
 *		[inbytes] => 54478
 *		[outpkts] => 401
 *		[outerrs] => 0
 *		[outbytes] => 327601
 *		[collisions] => 0
 *		[media] => 100baseTX
 *		[ipaddr] => 192.168.178.150
 *		[subnet] => 255.255.255.0
 *		[wolevents] => [
 *			"unicast",
 *			"multicast",
 *			"broadcast",
 *			"magic",
 *			"link"
 *		]
 *	Additional:
 *		[channel] => xxx
 *		[ssid] => xxx
 *	)
 */
function get_interface_info($if) {
//	global $config;

	$ifinfo = [];
	$ifinfo['hwif'] = get_ifname($if);
	$ifinfo['if'] = $ifinfo['hwif'];
//	run netstat to determine link info
	unset($linkinfo);
	exec('/usr/bin/netstat -I ' . $ifinfo['hwif'] . ' -nWb -f link',$linkinfo);
	$linkinfo = preg_split('/\s+/',ltrim($linkinfo[1]));
	if(preg_match('/\*$/',$linkinfo[0]) || preg_match('/^$/',$linkinfo[0])):
		$ifinfo['status'] = 'down';
	else:
		$ifinfo['status'] = 'up';
	endif;
	if(!strstr($ifinfo['if'],'tun')):
		$ifinfo['mtu'] = $linkinfo[1];
		$ifinfo['macaddr'] = $linkinfo[3];
		$ifinfo['inpkts'] = $linkinfo[4];
		$ifinfo['inerrs'] = $linkinfo[5];
		$ifinfo['indrop'] = $linkinfo[6];
		$ifinfo['inbytes'] = $linkinfo[7];
		$ifinfo['outpkts'] = $linkinfo[8];
		$ifinfo['outerrs'] = $linkinfo[9];
		$ifinfo['outbytes'] = $linkinfo[10];
		$ifinfo['collisions'] = $linkinfo[11];
	else:
		$ifinfo['inpkts'] = $linkinfo[3];
		$ifinfo['inbytes'] = $linkinfo[6];
		$ifinfo['outpkts'] = $linkinfo[7];
		$ifinfo['outbytes'] = $linkinfo[9];
	endif;
	if($ifinfo['status'] === 'up'):
//		try to determine media with ifconfig
		unset($ifconfiginfo);
		exec('/sbin/ifconfig -m ' . $ifinfo['hwif'],$ifconfiginfo);
		foreach($ifconfiginfo as $ici):
			if(preg_match('/media: .*? \((.*?)\)/',$ici,$matches)):
				$ifinfo['media'] = $matches[1];
			else:
				if(preg_match('/media: Ethernet (.*)/',$ici,$matches)):
					$ifinfo['media'] = $matches[1];
				endif;
			endif;
			if(preg_match('/status: (.*)$/',$ici,$matches)):
				if($matches[1] != 'active'):
					$ifinfo['status'] = $matches[1];
				endif;
			endif;
			if(preg_match('/channel (\S*)/',$ici,$matches)):
				$ifinfo['channel'] = $matches[1];
			endif;
			if(preg_match('/ssid (".*?"|\S*)/',$ici,$matches)):
				if($matches[1][0] == '"'):
					$ifinfo['ssid'] = substr($matches[1],1,-1);
				else:
					$ifinfo['ssid'] = $matches[1];
				endif;
			endif;
			if(preg_match('/supported wake events: (.*)$/',$ici,$matches)):
				$ifinfo['wolevents'] = explode(' ',$matches[1]);
			endif;
			if(preg_match('/capabilities=.*<(.*)>$/',$ici,$matches)):
				$info = explode(',',$matches[1]);
				$ifinfo['wolevents'] = preg_grep('/^WOL/',$info);
			endif;
		endforeach;
		$gather_ipinfo = true;
		if(isset($ifinfo['dhcplink']) && ('down' === $ifinfo['dhcplink'])):
			$gather_ipinfo = false;
		endif;
		if(isset($ifinfo['pppoelink']) && ('down' === $ifinfo['pppoelink'])):
			$gather_ipinfo = false;
		endif;
		if(isset($ifinfo['pptplink']) && ('down' === $ifinfo['pptplink'])):
			$gather_ipinfo = false;
		endif;
		if($gather_ipinfo):
//			try to determine IP address and netmask with ifconfig
			unset($ifconfiginfo);
			exec('/sbin/ifconfig ' . $ifinfo['if'],$ifconfiginfo);
			foreach($ifconfiginfo as $ici):
				if(preg_match('/inet (\S+)/',$ici,$matches)):
					$ifinfo['ipaddr'] = $matches[1];
				endif;
				if(preg_match('/netmask (\S+)/',$ici,$matches)):
					if(preg_match('/^0x/',$matches[1])):
						$ifinfo['subnet'] = long2ip(hexdec($matches[1]));
					endif;
				endif;
				if(preg_match('/inet6 (\S+)%/',$ici,$matches)):
					$ifinfo['ipv6addr'] = $matches[1];
				endif;
				if(preg_match('/prefixlen (\S+)/',$ici,$matches)):
					$ifinfo['ipv6subnet'] = $matches[1];
				endif;
			endforeach;
		endif;
	endif;
	return $ifinfo;
}
/*
 *	Get interface information.
 *	$iftype - interface type (e.g. lan, opt[n], ...)
 *	Result: Array
 *		see get_interface_info()
 *	Additional:
 *		[gateway] => 192.168.178.1
 *	)
 */
function get_interface_info_ex($iftype) {
	global $config;

//	get interface information
	$ifinfo = get_interface_info($config['interfaces'][$iftype]['if']);
//	get the default gateway if necessary
	if('lan' === $iftype):
//		run netstat to determine the default IPv4 gateway
		unset($netstatrninfo);
		exec('/usr/bin/netstat -rnf inet',$netstatrninfo);
		foreach($netstatrninfo as $nsr):
			if(preg_match('/^default\s*(\S+)/',$nsr,$matches)):
				$ifinfo['gateway'] = $matches[1];
			endif;
		endforeach;
//		run netstat to determine the default IPv6 gateway
		unset($netstatrninfo);
		exec('/usr/bin/netstat -rnf inet6',$netstatrninfo);
		foreach($netstatrninfo as $nsr):
			if(preg_match('/^default\s*(\S+)/',$nsr,$matches)):
				$ifinfo['ipv6gateway'] = $matches[1];
			endif;
		endforeach;
	endif;
	return $ifinfo;
}
/*
 *	Get carp interface information.
 */
function get_carp_info($if) {
	$ifinfo = [];
	$ifinfo['hwif'] = get_ifname($if);
	$ifinfo['if'] = $ifinfo['hwif'];
	exec('/sbin/ifconfig ' . $ifinfo['hwif'] . ' | grep carp:',$info);
	$info = preg_split('/\s+/',$info[0]);
	$ifinfo['state'] = $info[2];
	$ifinfo['vhid'] = $info[4];
	$ifinfo['advbase'] = $info[6];
	$ifinfo['advskew'] = $info[8];
	return $ifinfo;
}
/**
 *	Collects hast resource information via CLI
 *	@param string $hastresourcename
 *	@return array Array with hast resource information
 */
function get_hvol_info(string $hastresourcename) {
	$hvolinfo = [
		'error' => 0,
		'role' => 'unknown',
		'provname' => '',
		'localpath' => '',
		'remoteaddr' => '',
		'replication' => '',
		'status' => 'unknown'
	];
	$cmd = sprintf('/sbin/hastctl list %s 2>/dev/null',escapeshellarg($hastresourcename));
	exec($cmd,$rawdata);
	foreach($rawdata as $row):
		unset($matches);
		if(preg_match('/^\s+(?<key>[^:]+):\s+(?<val>.*)/',$row,$matches) === 1):
			if(array_key_exists($matches['key'],$hvolinfo)):
				$hvolinfo[$matches['key']] = $matches['val'];
			endif;
		endif;
	endforeach;
	return $hvolinfo;
}
/*
 *	Get hast role.
 */
function get_hast_role() {
	$role = 'unknown';
	if(0 == mwexec("/bin/pgrep -q -lf 'hastd: .* \\(primary\\)'")):
		$role = 'primary';
	endif;
	if(0 == mwexec("/bin/pgrep -q -lf 'hastd: .* \\(secondary\\)'")):
		$role = 'secondary';
	endif;
	return $role;
}
/*
 *	Get the product name
 */
function get_product_name() {
	global $g;
	return chop(file_get_contents("{$g['etc_path']}/prd.name"));
}
/*
 *	Get the platform type
 */
function get_platform_type() {
	global $g;
	return chop(file_get_contents("{$g['etc_path']}/platform"));
}
/*
 *	Get the product URL
 */
function get_product_url() {
	global $g;
	return chop(file_get_contents("{$g['etc_path']}/prd.url"));
}
/*
 *	Get the firmware check URL
 */
function get_firm_url() {
	global $g;
	return chop(file_get_contents("{$g['etc_path']}/firm.url"));
}
/*
 *	Get the product copyright note
 */
function get_product_copyright() {
	global $g;
	return chop(file_get_contents("{$g['etc_path']}/prd.copyright"));
}
/*
 *	Get the product version
 */
function get_product_version() {
	global $g;
	return chop(file_get_contents("{$g['etc_path']}/prd.version"));
}
/*
 *	Get the product revision
 */
function get_product_revision() {
	global $g;
	return chop(file_get_contents("{$g['etc_path']}/prd.revision"));
}
/*
 *	Get the product build time (formatted)
 */
function get_product_buildtime() {
	global $g;
	return chop(file_get_contents("{$g['etc_path']}/prd.version.buildtime"));
}
/*
 *	Get the product build timestamp
 */
function get_product_buildtimestamp() {
	global $g;
	return chop(file_get_contents("{$g['etc_path']}/prd.version.buildtimestamp"));
}
/*
 *	Get the product version name
 */
function get_product_versionname() {
	global $g;
	return chop(file_get_contents("{$g['etc_path']}/prd.version.name"));
}
/*
 *	Write message into log file.
 *	Return 0 if successful, otherwise 1
 */
function write_log($message) {
	$cmd= sprintf('/usr/bin/logger %s',escapeshellarg($message));
	return mwexec($cmd);
}
/*
 *	Display message on console.
 *	Return 0 if successful, otherwise 1
 */
function write_console($message) {
	echo($message);
	return 0;
}
/*
 *	Check if booting process is performed.
 *	Return true if booting, otherwise false
 */
function is_booting() {
	$val = getenv('BOOTING');
	return($val == 1);
}
function get_bootdevice() {
	$val = getenv('BOOTDEVICE');
	if($val === false):
		$val = '';
	endif;
	return $val;
}
/**
 *	Get list of configured physical disks.
 *	@param
 *	@return array list of configured physical disks or [].
 */
function get_conf_physical_disks_list() {
	global $config;

	$fallback = [];
	arr::make_branch($config,'disks','disk');
	arr::sort_key($config['disks']['disk'],'name');
	$a_disks = $config['disks']['disk'];
	foreach($a_disks as &$disk):
//		set disk type
		$disk['class'] = 'physical';
	endforeach;
	return array_merge($fallback,$a_disks);
}
/**
 *	Get list of configured software RAID disks.
 *	@param
 *	@return array list of configured software RAID disks or [].
 */
function get_conf_sraid_disks_list() {
	global $config;

	$fallback = [];
//	prepare environment
	arr::make_branch($config,'gvinum','vdisk');
	arr::sort_key($config['gvinum']['vdisk'],'name');
	$a_gvinum = $config['gvinum']['vdisk'];
	foreach($a_gvinum as &$vdisk):
		$vdisk['class'] = 'gvinum';
	endforeach;
	arr::make_branch($config,'gmirror','vdisk');
	arr::sort_key($config['gmirror']['vdisk'],'name');
	$a_gmirror = $config['gmirror']['vdisk'];
	foreach($a_gmirror as &$vdisk):
		$vdisk['class'] = 'gmirror';
	endforeach;
	arr::make_branch($config,'gconcat','vdisk');
	arr::sort_key($config['gconcat']['vdisk'],'name');
	$a_gconcat = $config['gconcat']['vdisk'];
	foreach($a_gconcat as &$vdisk):
		$vdisk['class'] = 'gconcat';
	endforeach;
	arr::make_branch($config,'gstripe','vdisk');
	arr::sort_key($config['gstripe']['vdisk'],'name');
	$a_gstripe = $config['gstripe']['vdisk'];
	foreach($a_gstripe as &$vdisk):
		$vdisk['class'] = 'gstripe';
	endforeach;
//	merge information
	return array_merge($fallback,$a_gvinum,$a_gmirror,$a_gconcat,$a_gstripe);
}
/**
 *	Get list of configured encrypted disks.
 *	@param
 *	@return array list of configured encrypted disks or [].
 */
function get_conf_encryped_disks_list() {
	global $config;

	$fallback = [];
//	prepare environment
	arr::make_branch($config,'geli','vdisk');
	arr::sort_key($config['geli']['vdisk'],'name');
	$a_geli = $config['geli']['vdisk'];
	foreach($a_geli as &$vdisk):
//		set disk type
		$vdisk['class'] = 'geli';
	endforeach;
	return array_merge($fallback,$a_geli);
}
/**
 *	Get list of configured ZFS virtual devices.
 *	@param
 *	@return array list of configured ZFS virtual devices or [].
 */
function get_conf_zfs_vdevice_list() {
	global $config;

	$fallback = [];
//	prepare environment
	arr::make_branch($config,'zfs','vdevices','vdevice');
	arr::sort_key($config['zfs']['vdevices']['vdevice'],'name');
	$a_vdevice = $config['zfs']['vdevices']['vdevice'];
	foreach($a_vdevice as &$vdevice):
//		set disk type
		$vdevice['class'] = 'vdevice';
	endforeach;
	return array_merge($fallback,$a_vdevice);
}
/**
 *	Get a filtered list of all configured disks (real and virtual, e.g. SoftRAID or GEli encrypted).
 *	Physical disks used by any virtual disk is filtered out. Also virtual disks itself are
 *	filtered if they are used by another virtual disk.
 *	@param
 *	@return array list of all configured disks or [].
 */
function get_conf_all_disks_list_filtered() {
//	global $config;

	$a_disk = [];
//	get list of physical disks
	$a_physicaldisk = get_conf_physical_disks_list();
//	get list of Software RAID disks
	$a_sraiddisk = get_conf_sraid_disks_list();
//	get list of encrypted disks
	$a_encrypteddisk = get_conf_encryped_disks_list();
//	get list of ZFS virtual devices
	$a_zfsvdevice = get_conf_zfs_vdevice_list();
//	first add physical disks if they are not used by a virtual disk
	foreach($a_physicaldisk as $disk):
		$unused = true;
//		check Software RAID volumes
		foreach($a_sraiddisk as $vdisk):
			if(is_array($vdisk['device'])):
				if(array_search($disk['devicespecialfile'],$vdisk['device']) !== false):
					$unused = false;
					break;
				endif;
			endif;
		endforeach;
//		check encrypted disks
		foreach($a_encrypteddisk as $vdisk):
			if(array_search($disk['devicespecialfile'],$vdisk['device']) !== false):
				$unused = false;
				break;
			endif;
		endforeach;
//		check ZFS virtual devices
		foreach($a_zfsvdevice as $vdisk):
			if(array_search($disk['devicespecialfile'],$vdisk['device']) !== false):
				$unused = false;
				break;
			endif;
			if(array_search($disk['devicespecialfile'] . ($disk['zfsgpt'] ?? ''),$vdisk['device']) !== false):
				$unused = false;
				break;
			endif;
		endforeach;
//		append physical disk if not used by any virtual disk
		if($unused === true):
			$a_disk[] = $disk;
		endif;
	endforeach;
//	add configured Software RAID disks. Check if they are not used by a
//	virtual disk itself
	foreach($a_sraiddisk as $disk):
		$unused = true;
//		check Software RAID volumes
		foreach($a_sraiddisk as $vdisk):
			if(is_array($vdisk['device'])):
				if(array_search($disk['devicespecialfile'],$vdisk['device']) !== false):
					$unused = false;
					break;
				endif;
			endif;
		endforeach;
//		check encrypted disks
		foreach($a_encrypteddisk as $vdisk):
			if(array_search($disk['devicespecialfile'],$vdisk['device']) !== false):
				$unused = false;
				break;
			endif;
		endforeach;
//		append virtual disk if not used by any other virtual disk
		if($unused === true):
			$a_disk[] = $disk;
		endif;
	endforeach;
//	add configured encrypted disks
	$a_disk = array_merge($a_disk,$a_encrypteddisk);
	return $a_disk;
}
/*
 *	Get a filtered list of configured disks (real and virtual, e.g. SoftRAID or GEli encrypted).
 *	List is filtered by given key and value.
 *	$key - Key used to filter (e.g. fstype, devicespecialfile or name)
 *	$pattern - pattern used for filtering (e.g. key=fstype pattern=softraid)
 *	Return list containing disks matching filter criterias.
 */
function get_conf_disks_filtered_ex($key,$pattern) {
	$result = [];
//	get all configured disks
	$a_disk = array_merge(get_conf_physical_disks_list(),get_conf_sraid_disks_list(),get_conf_encryped_disks_list());
	if(is_array($a_disk)):
		foreach($a_disk as $disk):
			if(!isset($disk[$key])):
				continue;
			endif;
			if(1 <= preg_match("/{$pattern}/",$disk[$key])):
				$result[] = $disk;
			endif;
		endforeach;
	endif;
	return $result;
}
/*
 *	Set the given file system type in configuration.
 *	Return 0 if successful, otherwise 1.
 */
function set_conf_disk_fstype_opt($disk,$fstype,$opt) {
	global $config;

	$result = 1;
	$diskconf = [
		'disks' => 'disk',
		'gconcat' => 'vdisk',
		'gmirror' => 'vdisk',
		'gstripe' => 'vdisk',
		'gvinum' => 'vdisk',
		'geli' => 'vdisk'
	];
	foreach($diskconf as $class => $val):
		arr::make_branch($config,$class,$val);
		$id = arr::search_ex($disk,$config[$class][$val],'devicespecialfile');
		if($id !== false):
			$config[$class][$val][$id]['fstype'] = $fstype;
//			add zfsgpt information if filesystem is zfs, remove when not
			if(!empty($opt) && $fstype == 'zfs' && isset($opt['zfsgpt'])):
				$config[$class][$val][$id]['zfsgpt'] = $opt['zfsgpt'];
			elseif(isset($config[$class][$val][$id]['zfsgpt'])):
				unset($config[$class][$val][$id]['zfsgpt']);
			endif;
			$result = 0;
			break;
		endif;
	endforeach;
	return $result;
}
/*
 *
 */
function set_conf_disk_fstype($disk,$fstype) {
	 return set_conf_disk_fstype_opt($disk,$fstype,null);
}
/*
 *	Get the Internet host name corresponding to a given IP address.
 *	Returns the host name or the unmodified ip_address on failure.
 */
function get_hostbyaddr($ip_address) {
	$host = gethostbyaddr($ip_address);
	if($host != false):
		return $host;
	endif;
	exec("/usr/bin/host {$ip_address}",$rawdata);
	if(preg_match('/^Name: (\S+)/',$rawdata[0],$matches)):
		return $matches[1];
	endif;
	return $ip_address;
}
/**
 *	Create a pseudo-random UUID according to RFC 4122.
 *	@return string
 */
function uuid() {
	return uuid::create_v4();
}
/*	Get the file size in bytes.
 *	Fix PHP file size problem (see http://de.php.net/manual/en/function.filesize.php).
 */
function get_filesize($file) {
	if(preg_match('#^/dev/zvol/(.+)$#',"{$file}",$m) && !empty($m[1])):
		$volname = str_replace('//','/',$m[1]);
		return @exec('zfs get -Hp -o value volsize ' . escapeshellarg($volname));
	endif;
	return @exec('stat -f %z ' . escapeshellarg($file));
}
/**
 * Converts an integer or an integer string into a human readable format for unit byte.
 * @param int/string $value Value to be converted into a human readable format.
 * @param int $precision The number of decimal digits. Default is 2.
 * @param bool $fixedformat Flag to format the returned string with the number of decimals given by $precision. Default is true.
 * @param bool $use_si Use SI divisor (1000) or binary divisor (1024). Default is true.
 * @return string Human readable version of bytes.
 */
function format_bytes($number,int $precision = 2,bool $fixedformat = true,bool $use_si = true) {
	if(!is_scalar($number)):
		$number = 0;
	endif;
	if($number < 0):
		$number = 0;
	endif;
	$str_number = (string)$number;
	$decimals = filter_var($precision,FILTER_VALIDATE_INT,['options' => ['default' => 2,'min_range' => 0]]);
	if($use_si):
//		si, 1000
		$unit_grid = ['B','kB','MB','GB','TB','PB','EB','ZB','YB'];
		$unit_overflow = '#B';
		$str_divisor = '1000';
	else:
//		non-si, 1024
		$unit_grid = ['B','KiB','MiB','GiB','TiB','PiB','EiB','ZiB','YiB'];
		$unit_overflow = '#iB';
		$str_divisor = '1024';
	endif;
	for($laps = 0;bccomp($str_number,$str_divisor) >= 0;$laps++):
		$str_number = bcdiv($str_number,$str_divisor,$decimals);
	endfor;
	return sprintf($fixedformat ? '%.' . $decimals . 'f %s' : '%s %s',(float)$str_number,$unit_grid[$laps] ?? $unit_overflow);
}
/**
 * Converts an integer or an integer string into a human readable format for unit Hertz.
 * @param int/string $value Value to be converted into a human readable format.
 * @param int $precision The number of decimal digits. Default is 2.
 * @param bool $fixedformat Flag to format the returned string with the number of decimals given by $precision. Default is true.
 * @return string Human readable version of Hertz.
 */
function format_hertz($number,int $precision = 2,bool $fixedformat = true) {
	if(!is_scalar($number)):
		$number = 0;
	endif;
	if($number < 0):
		$number = 0;
	endif;
	$str_number = (string)$number;
	$decimals = filter_var($precision,FILTER_VALIDATE_INT,['options' => ['default' => 2,'min_range' => 0]]);
	$unit_grid = ['Hz','kHz','MHz','GHz','THz','PHz','EHz','ZHz','YHz'];
	$unit_overflow = '#Hz';
	$str_divisor = '1000';
	for($laps = 0;bccomp($str_number,$str_divisor) >= 0;$laps++):
		$str_number = bcdiv($str_number,$str_divisor,$decimals);
	endfor;
	return sprintf($fixedformat ? '%.' . $decimals . 'f %s' : '%s %s',(float)$str_number,$unit_grid[$laps] ?? $unit_overflow);
}
/**
 * Converts an integer or an integer string into a human readable format for unit bit.
 * @param int/string $value Value to be converted into a human readable format.
 * @param int $precision The number of decimal digits. Default is 2.
 * @param bool $fixedformat Flag to format the return string with the number of decimals given by $precision. Default is true.
 * @param bool $use_si Use SI divisor (1000) or binary divisor (1024). Default is true.
 * @return string Human readable version of bits.
 */
function format_bits($number,int $precision = 2,bool $fixedformat = true,bool $use_si = true) {
	if(!is_scalar($number)):
		$number = 0;
	endif;
	if($number < 0):
		$number = 0;
	endif;
	$str_number = (string)$number;
	$decimals = filter_var($precision,FILTER_VALIDATE_INT,['options' => ['default' => 2,'min_range' => 0]]);
	if($use_si):
//		si, 1000
		$unit_grid = ['bit','kbit','Mbit','Gbit','Tbit','Pbit','Ebit','Zbit','Ybit'];
		$unit_overflow = '#bit';
		$str_divisor = '1000';
	else:
//		non-si, 1024
		$unit_grid = ['bit','Kibit','Mibit','Gibit','Tibit','Pibit','Eibit','Zibit','Yibit'];
		$unit_overflow = '#ibit';
		$str_divisor = '1024';
	endif;
	for($laps = 0;bccomp($str_number,$str_divisor) >= 0;$laps++):
		$str_number = bcdiv($str_number,$str_divisor,$decimals);
	endfor;
	return sprintf($fixedformat ? '%.' . $decimals . 'f %s' : '%s %s',(float)$str_number,$unit_grid[$laps] ?? $unit_overflow);
}
/*
 * Check and get the ISO image type.
 * Valid identifiers:
 * @code
 * 32769   string    CD001     ISO 9660 CD-ROM filesystem data
 * 37633   string    CD001     ISO 9660 CD-ROM filesystem data (raw 2352 byte sectors)
 * 32776   string    CDROM     High Sierra CD-ROM filesystem data
 * 38913   string   !NSR0      ISO 9660 CD-ROM filesystem data
 * 38913   string    NSR01     UDF filesystem data (version 1.0)
 * 38913   string    NSR02     UDF filesystem data (version 1.5)
 * 38913   string    NSR03     UDF filesystem data (version 2.0)
 * @endcode
 * @param filename	Name of the file to check.
 * @return 'cd9660' or 'udf' if successful, otherwise false.
 */
function util_is_iso_image($filename) {
	$return = false;
	$validmagic = [
		'CD001' => 'cd9660',
		'CDROM' => 'cd9660',
		'NSR0' => 'udf',
		'NSR01' => 'udf',
		'NSR02' => 'udf',
		'NSR03' => 'udf',
		'BEA01' => 'udf'
	];
	$fh = fopen($filename,'r');
	if($fh === false):
		return $return;
	endif;
//	read various file positions.
	fseek($fh,32769,SEEK_SET);
	$magic[] = fgets($fh,6);
	fseek($fh,37633,SEEK_SET);
	$magic[] = fgets($fh,6);
	fseek($fh,32776,SEEK_SET);
	$magic[] = fgets($fh,6);
	fseek($fh,38913,SEEK_SET);
	$magic[] = fgets($fh,6);
	fclose($fh);
	foreach($validmagic as $validmagick => $validmagicv):
		if(array_search($validmagick,$magic) !== false):
			$return = $validmagicv;
			break;
		endif;
	endforeach;
	return $return;
}
/*
 * Write a string to a file. The data will be written to a temporary file of
 * the same name but ending with the pid of the current process. If successful,
 * the temporary file will be renamed to the original one.
 * @param[in] filename	Path to the file where to write the data.
 * @param[in] data			The data to write.
 * @param[in] binary		Force binary mode writing.
 * @return True if successful, otherwise false.
 */
function file_put_contents_safe($filename,$data,$binary = false) {
	$tmpfilename = sprintf('%s.%s',$filename,getmypid());
	if($binary === true):
		$mode =  'wb';
	else:
		$mode = 'w';
	endif;
	if(!($fd = fopen($tmpfilename,$mode))):
		return false;
	endif;
	if(!fwrite($fd,$data)):
		fclose($fd);
		return false;
	endif;
	fclose($fd);
	if(!rename($tmpfilename,$filename)):
		unlink($tmpfilename);
		return false;
	endif;
	return true;
}
/*
 *
 */
function set_php_timezone() {
	global $g,$config;

	$tz = $config['system']['timezone'];
	if(empty($tz)):
		$tz = 'Etc/UTC';
	endif;
	$lines = file('/usr/local/etc/php.ini');
	if($lines === false):
		return false;
	endif;
//	read lines of php.ini except timezone
	$out = '';
	foreach($lines as $line):
		if(preg_match('/^\s*date\.timezone\s*=\s*/',$line,$m)):
			continue;
		endif;
		$out .= rtrim($line) . "\n";
	endforeach;
//	add timezone
	$out .= "date.timezone = '" . $tz . "'\n";
//	write php.ini
	if(!file_put_contents_safe('/usr/local/etc/php.ini',$out)):
		return false;
	endif;
	return true;
}
/*
 *
 */
function crypt_sha512($password) {
	$method = '$6$';
//	SHA512 (salt=16 chars)
	$salt_len = 12;
//	16*(3/4)
	$salt_raw = openssl_random_pseudo_bytes($salt_len);
	if($salt_raw === false):
		return false;
	endif;
	$salt = base64_encode($salt_raw);
	if($salt === false):
		return false;
	endif;
	$hash = crypt($password,$method . $salt);
	return $hash;
}
/*
 *
 */
function mkpasswd($password) {
	return crypt_sha512($password);
}
function mkpasswdmd4(string $password) {
	return strtoupper(hash('md4',iconv('UTF-8','UTF-16LE',$password),false));
}
/*
 *	openssl compatible encryption/decryption + base64 encode/decode
 *	http://www.openssl.org/docs/crypto/EVP_BytesToKey.html
 */
function encrypt_aes256cbc($password,$data) {
//	openssl enc -aes-256-cbc -a -k $password < $data
	$magic = 'Salted__';
	$method = 'AES-256-CBC';
	$magic_len = strlen($magic);
//	PKCS5_SALT_LEN
	$salt_len = 8;
//	generate salt
	$salt = openssl_random_pseudo_bytes($salt_len);
	if($salt === false):
		return false;
	endif;
//	key derivation
	$hash0 = '';
	$hash1 = md5($hash0 . $password . $salt,true);
	$hash2 = md5($hash1 . $password . $salt,true);
	$hash3 = md5($hash2 . $password . $salt,true);
	$key = $hash1 . $hash2;
	$iv = $hash3;
//	encrypt by $method
	$enc = openssl_encrypt($data,$method,$key,OPENSSL_RAW_DATA,$iv);
	if($enc === false):
		return false;
	endif;
	$b64enc_data = base64_encode($magic . $salt . $enc);
	if($b64enc_data === false):
		return false;
	endif;
//	insert linefeed
	$folded_data = chunk_split($b64enc_data,76,"\n");
	return $folded_data;
}
function decrypt_aes256cbc($password,$b64enc_data) {
//	openssl enc -d -aes-256-cbc -a -k $password < $b64enc_config
	$magic = 'Salted__';
	$method = 'AES-256-CBC';
	$magic_len = strlen($magic);
//	PKCS5_SALT_LEN
	$salt_len = 8;
//	remove extra linefeed
	$b64enc_data = preg_replace('/\n|\r|\r\n/','',$b64enc_data);
//	split magic/salt/encrypted data
	$enc_data = base64_decode($b64enc_data);
	if($enc_data === false):
		return false;
	endif;
	if(strcmp(substr($enc_data,0,$magic_len),$magic) !== 0):
		return false;
	endif;
	$salt = substr($enc_data,$magic_len,$salt_len);
	$enc = substr($enc_data,$magic_len + $salt_len);
//	key derivation
	$hash0 = '';
	$hash1 = md5($hash0 . $password . $salt,true);
	$hash2 = md5($hash1 . $password . $salt,true);
	$hash3 = md5($hash2 . $password . $salt,true);
	$key = $hash1 . $hash2;
	$iv = $hash3;
//	decrypt by $method
	$dec = openssl_decrypt($enc,$method,$key,OPENSSL_RAW_DATA,$iv);
	if($dec === false):
		return false;
	endif;
	return $dec;
}
